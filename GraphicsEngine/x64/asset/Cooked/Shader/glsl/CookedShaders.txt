Compost_fs.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	//return float4(1,1,1,1); 
	float4 output = texColour.Sample(defaultSampler, input.uv); 
	//output.a = 0.25f; 
	return output; 
	 
} 
¬
DeferredWrite_fs.hlsl|FileStart|
Texture2D texColour : register( t0 ); 
SamplerState defaultSampler : register ( s0 ); 
 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float4 Normal :NORMAL0; 
	float2 uv : TEXCOORD; 
	float4 WorldPos:TANGENT0; 
}; 
struct FS_OUTPUT 
{ 
	float4 Gpos: SV_Target0; 
	float4 GNormal: SV_Target1; 
	float4 GAlbedoSpec: SV_Target2; 
	float4 GTangent: SV_Target3; 
}; 
FS_OUTPUT main(PSInput input )  
{ 
	FS_OUTPUT output = (FS_OUTPUT)0; 
	output.Gpos = input.WorldPos; 
	output.GNormal = float4(input.Normal.xyz,1.0f);//todo: remove this exta compoenent 
	output.GAlbedoSpec = float4(texColour.Sample(defaultSampler, input.uv).xyz, 1.0f); 
    return output; 
} 
¬
DeferredWrite_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register( b0 ) 
{ 
	row_major matrix world; 
	row_major matrix view; 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 normal : NORMAL0; 
	float3 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main( float4 pos : POSITION, float4 normal : NORMAL0, float3 uv : TEXCOORD0 ) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul( pos, world ); 
	result.WorldPos = final_pos; 
	final_pos = mul( final_pos, view ); 
	final_pos = mul( final_pos, projection ); 
 
	output.pos = final_pos; 
	output.normal = normal; 
	output.uv = uv; 
 
    return output; 
} 
¬
Deferred_LightingPass_fs.hlsl|FileStart|
Texture2D PosTexture : register(t0); 
Texture2D NormalTexture : register(t1); 
Texture2D AlbedoTexture : register(t2); 
SamplerState defaultSampler : register (s1); 
struct Light 
{ 
	float3 LPosition; 
	float3 color; 
	float3 Direction; 
	row_major matrix LightVP; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
}; 
//PBR functions! 
const float PI = 3.14159265359; 
float DistributionGGX(float3 N, float3 H, float roughness) 
{ 
	float a = roughness * roughness; 
	float a2 = a * a; 
	float NdotH = max(dot(N, H), 0.0); 
	float NdotH2 = NdotH * NdotH; 
 
	float num = a2; 
	float denom = (NdotH2 * (a2 - 1.0) + 1.0); 
	denom = PI * denom * denom; 
 
	return num / denom; 
} 
 
float GeometrySchlickGGX(float NdotV, float roughness) 
{ 
	float r = (roughness + 1.0); 
	float k = (r*r) / 8.0; 
 
	float num = NdotV; 
	float denom = NdotV * (1.0 - k) + k; 
 
	return num / denom; 
} 
float GeometrySmith(float3 N, float3 V, float3 L, float roughness) 
{ 
	float NdotV = max(dot(N, V), 0.0); 
	float NdotL = max(dot(N, L), 0.0); 
	float ggx2 = GeometrySchlickGGX(NdotV, roughness); 
	float ggx1 = GeometrySchlickGGX(NdotL, roughness); 
 
	return ggx1 * ggx2; 
} 
 
 
float3 Phong_Diffuse(float3 MaterialDiffuseColor, float3 LightDir, float3 Normal) 
{ 
	float diffu = max(dot(Normal, LightDir), 0.0);//diffuse 
	return MaterialDiffuseColor * diffu; 
} 
 
float3 GetAmbient() 
{ 
	return float3(0.2, 0.2, 0.2); 
} 
 
 
float3 CalcColorFromLight(Light light,float3 Diffusecolor,float3 FragPos,float3 normal) 
{ 
	float3 LightDirection = float3(0, 1, 0); 
	float distanceToLight = length(light.LPosition - FragPos); 
	float attenuation = 1.0f; 
 
	if (light.type == 1) 
	{ 
		LightDirection = normalize(light.LPosition - FragPos); 
		attenuation = 1.0 / (1.0 + 0.001 * pow(distanceToLight, 2)); 
	} 
	else 
	{ 
		LightDirection = -light.Direction; 
	} 
 
	float3 Diffusecolour = Phong_Diffuse(Diffusecolor, LightDirection, normal) * light.color; 
	return Diffusecolour * attenuation; 
} 
 
#define MAX_LIGHT 4 
 
cbuffer LightBuffer : register(b1) 
{ 
	Light lights[MAX_LIGHT]; 
}; 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	float4 pos = PosTexture.Sample(defaultSampler, input.uv); 
	float4 normal = NormalTexture.Sample(defaultSampler, input.uv); 
	float4 AlbedoSpec = AlbedoTexture.Sample(defaultSampler, input.uv); 
	float3 Diffusecolour = AlbedoSpec.xyz * GetAmbient(); 
	for (int i = 0; i < MAX_LIGHT; i++) 
	{ 
		Diffusecolour += CalcColorFromLight(lights[i], AlbedoSpec.xyz, pos.xyz, normalize(normal.xyz)); 
	} 
	return float4(Diffusecolour,1.0f); 
} 
¬
Deferred_LightingPass_vs.hlsl|FileStart|
 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 position : POSITION /*float4 normal : NORMAL0,*/ /*float4 uv : TEXCOORD*/) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = position; 
	const float2 fliped = float2 (position.x, -position.y); 
	output.uv = (fliped + float2(1, 1)) / 2.0f; 
	return output; 
} 
¬
Lighting.hlsl|FileStart|
struct Light 
{ 
	float3 LPosition; 
	float3 color; 
	float3 Direction; 
	row_major matrix LightVP; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
}; 
//PBR functions! 
const float PI = 3.14159265359; 
float DistributionGGX(float3 N, float3 H, float roughness) 
{ 
	float a = roughness * roughness; 
	float a2 = a * a; 
	float NdotH = max(dot(N, H), 0.0); 
	float NdotH2 = NdotH * NdotH; 
 
	float num = a2; 
	float denom = (NdotH2 * (a2 - 1.0) + 1.0); 
	denom = PI * denom * denom; 
 
	return num / denom; 
} 
 
float GeometrySchlickGGX(float NdotV, float roughness) 
{ 
	float r = (roughness + 1.0); 
	float k = (r*r) / 8.0; 
 
	float num = NdotV; 
	float denom = NdotV * (1.0 - k) + k; 
 
	return num / denom; 
} 
float GeometrySmith(float3 N, float3 V, float3 L, float roughness) 
{ 
	float NdotV = max(dot(N, V), 0.0); 
	float NdotL = max(dot(N, L), 0.0); 
	float ggx2 = GeometrySchlickGGX(NdotV, roughness); 
	float ggx1 = GeometrySchlickGGX(NdotL, roughness); 
 
	return ggx1 * ggx2; 
} 
 
 
float3 Phong_Diffuse(float3 MaterialDiffuseColor, float3 LightDir, float3 Normal) 
{ 
	float diffu = max(dot(Normal, LightDir), 0.0);//diffuse 
	return MaterialDiffuseColor * diffu; 
} 
 
float3 GetAmbient() 
{ 
	return float3(0.2, 0.2, 0.2); 
} 
 
 
float3 CalcColorFromLight(Light light,float3 Diffusecolor,float3 FragPos,float3 normal) 
{ 
	float3 LightDirection = float3(0, 1, 0); 
	float distanceToLight = length(light.LPosition - FragPos); 
	float attenuation = 1.0f; 
 
	if (light.type == 1) 
	{ 
		LightDirection = normalize(light.LPosition - FragPos); 
		attenuation = 1.0 / (1.0 + 0.001 * pow(distanceToLight, 2)); 
	} 
	else 
	{ 
		LightDirection = -light.Direction; 
	} 
 
	float3 Diffusecolour = Phong_Diffuse(Diffusecolor, LightDirection, normal) * light.color; 
	return Diffusecolour * attenuation; 
} 
¬
Main_fs.hlsl|FileStart|
Texture2D texColour : register( t0 ); 
SamplerState defaultSampler : register ( s0 ); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float4 normal : NORMAL0; 
	float3 uv : TEXCOORD0; 
}; 
 
float4 main( VS_OUTPUT input ) : SV_Target 
{ 
    return texColour.Sample( defaultSampler, input.uv ); 
} 
¬
Main_fs_12.hlsl|FileStart|
struct Light 
{ 
	float3 LPosition; 
	float3 color; 
	float3 Direction; 
	row_major matrix LightVP; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
}; 
//PBR functions! 
const float PI = 3.14159265359; 
float DistributionGGX(float3 N, float3 H, float roughness) 
{ 
	float a = roughness * roughness; 
	float a2 = a * a; 
	float NdotH = max(dot(N, H), 0.0); 
	float NdotH2 = NdotH * NdotH; 
 
	float num = a2; 
	float denom = (NdotH2 * (a2 - 1.0) + 1.0); 
	denom = PI * denom * denom; 
 
	return num / denom; 
} 
 
float GeometrySchlickGGX(float NdotV, float roughness) 
{ 
	float r = (roughness + 1.0); 
	float k = (r*r) / 8.0; 
 
	float num = NdotV; 
	float denom = NdotV * (1.0 - k) + k; 
 
	return num / denom; 
} 
float GeometrySmith(float3 N, float3 V, float3 L, float roughness) 
{ 
	float NdotV = max(dot(N, V), 0.0); 
	float NdotL = max(dot(N, L), 0.0); 
	float ggx2 = GeometrySchlickGGX(NdotV, roughness); 
	float ggx1 = GeometrySchlickGGX(NdotL, roughness); 
 
	return ggx1 * ggx2; 
} 
 
 
float3 Phong_Diffuse(float3 MaterialDiffuseColor, float3 LightDir, float3 Normal) 
{ 
	float diffu = max(dot(Normal, LightDir), 0.0);//diffuse 
	return MaterialDiffuseColor * diffu; 
} 
 
float3 GetAmbient() 
{ 
	return float3(0.2, 0.2, 0.2); 
} 
 
 
float3 CalcColorFromLight(Light light,float3 Diffusecolor,float3 FragPos,float3 normal) 
{ 
	float3 LightDirection = float3(0, 1, 0); 
	float distanceToLight = length(light.LPosition - FragPos); 
	float attenuation = 1.0f; 
 
	if (light.type == 1) 
	{ 
		LightDirection = normalize(light.LPosition - FragPos); 
		attenuation = 1.0 / (1.0 + 0.001 * pow(distanceToLight, 2)); 
	} 
	else 
	{ 
		LightDirection = -light.Direction; 
	} 
 
	float3 Diffusecolour = Phong_Diffuse(Diffusecolor, LightDirection, normal) * light.color; 
	return Diffusecolour * attenuation; 
} 
 
 
#define SHADOW_DEPTH_BIAS 0.005f 
cbuffer LightBuffer : register(b1) 
{ 
	Light lights[MAX_LIGHTS]; 
}; 
cbuffer GOConstantBuffer : register(b0) 
{ 
	row_major matrix Model; 
	int HasNormalMap; 
}; 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float4 Normal :NORMAL0; 
	float2 uv : TEXCOORD0; 
	float4 WorldPos:TANGENT0; 
	row_major float3x3 TBN:TANGENT1; 
}; 
SamplerState g_sampler : register(s0); 
SamplerState g_Clampsampler : register(s1); 
Texture2D g_texture : register(t0); 
Texture2D NormalMapTexture : register(t1); 
 
 
Texture2D g_Shadow_texture[MAX_DIR_SHADOWS]: register(t3); 
TextureCube g_Shadow_texture2[MAX_POINT_SHADOWS] : register(POINT_SHADOW_OFFSET); 
float GetShadow(float4 pos) 
{ 
	float4 vLightSpacePos = pos; 
	//vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].view); 
	//vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].projection); 
	vLightSpacePos = mul(vLightSpacePos, lights[0].LightVP); 
	vLightSpacePos.xyz /= vLightSpacePos.w; 
	float2 vShadowTexCoord = 0.5f * vLightSpacePos.xy + 0.5f; 
	vShadowTexCoord.y = 1.0f - vShadowTexCoord.y; 
	float bias = 0.005; 
	if (g_Shadow_texture[0].Sample(g_sampler, vShadowTexCoord.xy).r < (vLightSpacePos.z - bias)) 
	{ 
		return 1.0f; 
	} 
	return 0.0f; 
} 
float4 CalcUnshadowedAmountPCF2x2(int lightid, float4 vPosWorld) 
{ 
	// Compute pixel position in light space. 
	float4 vLightSpacePos = vPosWorld; 
	vLightSpacePos = mul(vLightSpacePos, lights[lightid].LightVP); 
 
	vLightSpacePos.xyz /= vLightSpacePos.w; 
 
	// Translate from homogeneous coords to texture coords. 
	float2 vShadowTexCoord = 0.5f * vLightSpacePos.xy + 0.5f; 
	vShadowTexCoord.y = 1.0f - vShadowTexCoord.y; 
 
	// Depth bias to avoid pixel self-shadowing. 
	float vLightSpaceDepth = vLightSpacePos.z - SHADOW_DEPTH_BIAS; 
 
	// Find sub-pixel weights.//todo: shader define! 
	float2 vShadowMapDims = float2(1024, 1024); // need to keep in sync with .cpp file 
	float size = 1.0f; 
	float4 vSubPixelCoords = float4(size, size, size, size); 
	vSubPixelCoords.xy = frac(vShadowMapDims * vShadowTexCoord); 
	vSubPixelCoords.zw = 1.0f - vSubPixelCoords.xy; 
	float4 vBilinearWeights = vSubPixelCoords.zxzx * vSubPixelCoords.wwyy; 
 
	// 2x2 percentage closer filtering. 
	float2 vTexelUnits = 1.0f / vShadowMapDims; 
	float4 vShadowDepths; 
	int id = 0; 
	if (lightid == 0) 
	{ 
		vShadowDepths.x = g_Shadow_texture[id].Sample(g_Clampsampler, vShadowTexCoord); 
		vShadowDepths.y = g_Shadow_texture[id].Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
		vShadowDepths.z = g_Shadow_texture[id].Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
		vShadowDepths.w = g_Shadow_texture[id].Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits); 
	} 
	else 
	{ 
		/*vShadowDepths.x = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord); 
		vShadowDepths.y = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
		vShadowDepths.z = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
		vShadowDepths.w = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits);*/ 
	} 
	// What weighted fraction of the 4 samples are nearer to the light than this pixel? 
	float4 vShadowTests = (vShadowDepths >= vLightSpaceDepth) ? 1.0f : 0.0f; 
	return dot(vBilinearWeights, vShadowTests); 
} 
float ShadowCalculationCube(const float3 fragPos, Light lpos); 
 
float4 main(PSInput input) : SV_TARGET 
{ 
	float3 texturecolour = g_texture.Sample(g_sampler, input.uv); 
	float3 Normal = input.Normal.xyz; 
	if (HasNormalMap == 1) 
	{ 
		Normal = (NormalMapTexture.Sample(g_sampler, input.uv).xyz)*2.0 - 1.0; 
		Normal = normalize(mul(Normal,input.TBN)); 
	} 
	float3 output = float3(0, 0, 0); 
	for (int i = 0; i < MAX_LIGHTS; i++) 
	{ 
		float3 colour = CalcColorFromLight(lights[i], texturecolour, input.WorldPos.xyz,normalize(Normal)); 
		if (lights[i].HasShadow && lights[i].type == 0) 
		{ 
			colour *= CalcUnshadowedAmountPCF2x2(i, input.WorldPos); 
		} 
		if (lights[i].HasShadow && lights[i].type == 1) 
		{ 
			colour *= 1.0 - ShadowCalculationCube(input.WorldPos.xyz, lights[i]); 
		} 
		output += colour; 
	} 
 
	float3 ambeint = texturecolour * GetAmbient(); 
	float3 GammaCorrected = ambeint + output; 
	//float gamma = 1.0f / 2.2f; 
	//	GammaCorrected = pow(GammaCorrected, float4(gamma, gamma, gamma, gamma)); 
	return float4(GammaCorrected.xyz,1.0f); 
} 
 
 
float ShadowCalculationCube(const float3 fragPos, Light lpos) 
{ 
	// Get vector between fragment position and light position 
	float3 fragToLight = (fragPos - lpos.LPosition); 
	float currentDepth = length(fragToLight); 
	//if (currentDepth > MaxShadowDistance) 
	//{ 
	//	//	return 0.0f; 
	//} 
	float shadow = 0.0f; 
	float bias = 0.5f; 
	int samples = 1; 
	/*float viewDistance = length(viewPos - fragPos); 
	float diskRadius = (1.0f + (viewDistance / far_plane)) / 25.0f;*/ 
	float far_plane = 500; 
 
	float closestDepth = 0; 
	float3 val = float3(1, 0, 0); 
	/*if (lpos.ShadowID == 0) 
	{ 
		return 0.0f; 
	}*/ 
	int id = lpos.ShadowID; 
	//if (lpos.ShadowID == 0) 
	//{ 
	//	id = 1; 
	//} 
	//if (lpos.ShadowID == 1) 
	//{ 
	//	id = 0; 
	//} 
	closestDepth = g_Shadow_texture2[id].Sample(g_Clampsampler, (fragToLight)).r; 
 
	closestDepth *= far_plane; 
 
	if (currentDepth - bias > closestDepth) 
	{ 
		return 1.0f; 
	} 
 
	//shadow /= float(samples);//average of samples 
	//						 //cleanup the low shadow areas 
	/*if (shadow < 0.25f) 
	{ 
		return 0.0f; 
	}*/ 
	return 0.0f; 
} 
¬
Main_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register( b0 ) 
{ 
	row_major matrix world; 
	row_major matrix view; 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float4 normal : NORMAL0; 
	float3 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main( float4 pos : POSITION, float4 normal : NORMAL0, float3 uv : TEXCOORD0 ) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul( pos, world ); 
	 
	final_pos = mul( final_pos, view ); 
	final_pos = mul( final_pos, projection ); 
 
	output.pos = final_pos; 
	output.normal = normal; 
	output.uv = uv; 
 
    return output; 
} 
¬
Main_vs_12.hlsl|FileStart|
 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float4 Normal :NORMAL0; 
	float2 uv : TEXCOORD; 
	float4 WorldPos:TANGENT0; 
	row_major float3x3 TBN:TANGENT1; 
}; 
 
Texture2D g_texture : register(t0); 
SamplerState g_sampler : register(s0); 
 
cbuffer GOConstantBuffer : register(b0) 
{ 
	row_major matrix Model; 
	int HasNormalMap; 
}; 
cbuffer SceneConstantBuffer : register(b2) 
{ 
	row_major matrix View; 
	row_major matrix Projection; 
}; 
 
PSInput main(float4 position : POSITION, float4 normal : NORMAL0, float4 uv : TEXCOORD,float4 Tangent: TANGENT0) 
{ 
	PSInput result; 
	float4 final_pos = position; 
	final_pos.w = 1.0f; 
	final_pos = mul(position, Model); 
	result.WorldPos = final_pos; 
	final_pos = mul(final_pos, View); 
	final_pos = mul(final_pos, Projection); 
	result.position = final_pos; 
	result.uv = uv.xy; 
	result.Normal = normal; 
	if (HasNormalMap) 
	{ 
		const float3 BiTangent = (mul(float4(cross(normal.xyz, Tangent.xyz).xyz, 0.0), Model)); 
		const float3 Normal = (mul(float4(normal.xyz, 0.0), Model)); 
		const float3 tan = (mul(float4(Tangent.xyz, 0.0), Model)); 
		float3x3 mat = float3x3(tan, BiTangent, Normal); 
		result.TBN = mat; 
	} 
	return result; 
} 
¬
MipmapCS.hlsl|FileStart|
Texture2D<float4> SrcTexture : register(t0); 
RWTexture2D<float4> DstTexture : register(u0); 
SamplerState BilinearClamp : register(s0); 
 
cbuffer CB : register(b0) 
{ 
	float2 TexelSize;   // 1.0 / destination dimension 
} 
 
[numthreads(8, 8, 1)] 
void main(uint3 DTid : SV_DispatchThreadID) 
{ 
	//DTid is the thread ID * the values from numthreads above and in this case correspond to the pixels location in number of pixels. 
	//As a result texcoords (in 0-1 range) will point at the center between the 4 pixels used for the mipmap. 
	//TexelSize = 1.0 / 256; 
	//(1.0 / 256)  
	float2 texcoords = TexelSize * (DTid.xy + 0.5); 
 
	//The samplers linear interpolation will mix the four pixel values to the new pixels color 
	float4 color = SrcTexture.SampleLevel(BilinearClamp, texcoords, 0); 
 
	//Write the final color into the destination texture. 
	DstTexture[DTid.xy] = color; 
} 
¬
Pass_fs.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	return texColour.Sample(defaultSampler, input.uv); 
	//return float4(1,1,1,1); 
} 
¬
Pass_fs_12.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	//return float4(1,1,1,1); 
	float4 output = texColour.Sample(defaultSampler, input.uv); 
 
	float exposure = 2.5f; 
	float4 mapped = float4(1.0,1.0,1.0,1.0) - exp(-output * exposure); 
 
#if 0 
	float gamma = 1.0f / 2.2f; 
	output = pow(output, float4(gamma, gamma, gamma, gamma)); 
#endif 
	return mapped; 
	 
} 
¬
Pass_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix world; 
	row_major matrix view; 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 pos : POSITION, float3 uv : TEXCOORD0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul(pos, world); 
 
	//final_pos = mul(final_pos, view); 
	//final_pos = mul(final_pos, projection); 
 
	output.pos = final_pos; 
 
	//output.uv = uv; 
	float2 u = (pos.xy + float2(1, 1)) / 2.0; 
	output.uv = float3(u.x, -u.y, 0); 
	return output; 
} 
¬
Pass_vs_12.hlsl|FileStart|
 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 position : POSITION /*float4 normal : NORMAL0,*/ /*float4 uv : TEXCOORD*/) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
//	float4 final_pos = mul(position, world); 
// 
//	//final_pos = musssl(final_pos, view); 
//	//final_pos = mul(final_pos, projection); 
////	output.normal = float3(0, 0, -1); 
//	output.pos = float4(position.xy, 0, 10.0f); 
// 
//	//output.uv = uv; 
//	float2 u = (position.xy + float2(1, 1)) / 2.2; 
//	//output.uv = uv;// u;///float3(u.x, -u.y, 0); 
	 
	output.pos = position; 
	const float2 fliped = float2 (position.x, -position.y); 
	output.uv = (fliped + float2(1, 1)) / 2.0f; 
	return output; 
} 
¬
PostProcessBase_VS.hlsl|FileStart|
 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 position : POSITION /*float4 normal : NORMAL0,*/ /*float4 uv : TEXCOORD*/) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = position; 
	const float2 fliped = float2 (position.x, -position.y); 
	output.uv = (fliped + float2(1, 1)) / 2.0f; 
	return output; 
} 
¬
Shadow.hlsl|FileStart|
#define SHADOW_DEPTH_BIAS 0.005f 
loat4 CalcUnshadowedAmountPCF2x2(int lightid, float4 vPosWorld) 
{ 
	// Compute pixel position in light space. 
	float4 vLightSpacePos = vPosWorld; 
	vLightSpacePos = mul(vLightSpacePos, lights[lightid].LightVP); 
 
	vLightSpacePos.xyz /= vLightSpacePos.w; 
 
	// Translate from homogeneous coords to texture coords. 
	float2 vShadowTexCoord = 0.5f * vLightSpacePos.xy + 0.5f; 
	vShadowTexCoord.y = 1.0f - vShadowTexCoord.y; 
 
	// Depth bias to avoid pixel self-shadowing. 
	float vLightSpaceDepth = vLightSpacePos.z - SHADOW_DEPTH_BIAS; 
 
	// Find sub-pixel weights.//todo: shader define! 
	float2 vShadowMapDims = float2(1024, 1024); // need to keep in sync with .cpp file 
	float size = 1.0f; 
	float4 vSubPixelCoords = float4(size, size, size, size); 
	vSubPixelCoords.xy = frac(vShadowMapDims * vShadowTexCoord); 
	vSubPixelCoords.zw = 1.0f - vSubPixelCoords.xy; 
	float4 vBilinearWeights = vSubPixelCoords.zxzx * vSubPixelCoords.wwyy; 
 
	// 2x2 percentage closer filtering. 
	float2 vTexelUnits = 1.0f / vShadowMapDims; 
	float4 vShadowDepths; 
	if (lightid == 0) 
	{ 
		vShadowDepths.x = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord); 
		vShadowDepths.y = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
		vShadowDepths.z = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
		vShadowDepths.w = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits); 
	} 
	else 
	{ 
		/*vShadowDepths.x = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord); 
		vShadowDepths.y = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
		vShadowDepths.z = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
		vShadowDepths.w = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits);*/ 
	} 
	// What weighted fraction of the 4 samples are nearer to the light than this pixel? 
	float4 vShadowTests = (vShadowDepths >= vLightSpaceDepth) ? 1.0f : 0.0f; 
	return dot(vBilinearWeights, vShadowTests); 
} 
¬
Skybox_fs.hlsl|FileStart|
 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float3 texcoord :TEXCOORD; 
}; 
 
TextureCube g_texture : register(t0); 
SamplerState g_sampler : register(s1); 
 
 
float4 main(PSInput input) : SV_TARGET 
{ 
 
	return float4(g_texture.Sample(g_sampler,input.texcoord).xyz,1.0f); 
	return float4(1.0f,1.0,1.0f,1.0f); 
} 
 
¬
Skybox_vs.hlsl|FileStart|
 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float3 texcoord :TEXCOORD; 
}; 
 
cbuffer SceneConstantBuffer : register(b0) 
{ 
	row_major matrix View; 
	row_major matrix Projection; 
}; 
 
PSInput main(float4 position : POSITION) 
{ 
	PSInput result; 
	float4 final_pos = float4(position.xyz,1.0); 
	final_pos = mul(final_pos, View); 
	final_pos = mul(final_pos, Projection); 
	result.position = final_pos.xyww; 
	result.texcoord = normalize(position.xyz); 
	return result; 
} 
¬
UI_Batch_fs.hlsl|FileStart|
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 FrontColour:TEXCOORD; 
	float3 BackColour:TEXCOORD1; 
	uint Back : TEXCOORD2; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	if (input.Back == 0 ) 
	{ 
		return float4(input.FrontColour.xyz, 0.0); 
	} 
	else 
	{ 
		return float4(input.BackColour.xyz,0.0); 
	} 
	 
} 
¬
UI_Batch_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 FrontColour:TEXCOORD; 
	float3 BackColour:TEXCOORD1; 
	uint Back: TEXCOORD2; 
}; 
 
 
VS_OUTPUT main(float2 position : POSITION, uint back : TEXCOORD2, float3 fc : TEXCOORD, float3 bc : TEXCOORD1) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 finalpos = float4(position.xy, 0.0, 1.0); 
	output.pos = mul(finalpos, projection); 
	output.FrontColour = fc; 
	output.Back = back; 
	output.BackColour = bc;	 
	return output; 
} 
¬
debugline_fs.hlsl|FileStart|
 
struct VS_OUTPUT 
{ 
	float4 pos    : SV_POSITION; 
	float3 colour : TEXCOORD0; 
}; 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	return float4(input.colour,1.0f); 
} 
¬
debugline_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos    : SV_POSITION; 
	float3 colour : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float3 pos : POSITION, float3 color : NORMAL0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
#if TWOD_ONLY 
	pos.z = 0.0f; 
#endif 
	output.pos = mul(float4(pos, 1.0), projection); 
	output.colour = color; 
	return output; 
} 
¬
depthbasic_fs_12.hlsl|FileStart|
struct GSOutput 
{ 
	float4 Pos : SV_POSITION; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: TEXCOORD0; 
	float3 WorldPos:NORMAL0; 
}; 
float main(GSOutput input) : SV_Depth 
{ 
#if DIRECTIONAL 
	return float4(1,1,1,1); 
#else 
	float Farplane = 500; 
	float LightDistance = length(input.WorldPos.xyz - input.LightPos); 
	LightDistance = LightDistance / Farplane; 
	return LightDistance; 
#endif 
} 
 
¬
depthbasic_geo.hlsl|FileStart|
cbuffer GeoTrans : register(b1) 
{ 
	row_major matrix worldm[6]; 
} 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: TEXCOORD0; 
	float3 WorldPos:NORMAL0; 
}; 
 
struct GSOutput 
{ 
	float4 Pos : SV_POSITION; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: TEXCOORD0; 
	float3 WorldPos:NORMAL0; 
}; 
 
[maxvertexcount(18)] 
void main(triangle VS_OUTPUT input[3], inout TriangleStream<GSOutput> OutputStream) 
{ 
	for (uint face = 0; face < 6; face += 1)//for each face 
	{ 
		GSOutput output = (GSOutput)0; 
		output.slice = face; 
		for (int i = 0; i < 3; ++i) // for each triangle's vertices 
		{ 
			output.WorldPos = input[i].pos.xyz; 
			output.Pos = mul(float4(input[i].pos.xyz,1.0f), worldm[face]);			 
			output.LightPos = input[i].LightPos; 
			OutputStream.Append(output); 
		} 
		OutputStream.RestartStrip(); 
	} 
 
} 
 
¬
depthbasic_vs_12.hlsl|FileStart|
 
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix world; 
} 
#if 0 
cbuffer SceneConstantBuffer : register(b2) 
{ 
	row_major matrix ViewP; 
	row_major matrix Projection; 
}; 
 
#else 
cbuffer SceneConstantBuffer : register(b2) 
{ 
	row_major matrix ViewP; 
	row_major matrix Projection; 
	float4 LightPos; 
}; 
#endif 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: TEXCOORD0; 
	float3 WorldPos:NORMAL0; 
}; 
 
 
VS_OUTPUT main(float4 pos : POSITION, float4 normal : NORMAL0, float3 uv : TEXCOORD0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul(float4(pos.xyz,1.0), world); 
#if DIRECTIONAL 
	final_pos = mul(final_pos, ViewP); 
	final_pos = mul(final_pos, Projection); 
#endif 
	output.pos = final_pos; 
	output.LightPos = LightPos; 
	return output; 
} 
¬
output_fs.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	return texColour.Sample(defaultSampler, input.uv); 
//return float4(1,1,1,1); 
} 
¬
output_vs.hlsl|FileStart|
 
cbuffer LineConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
	float3 Colour; 
} 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
VS_OUTPUT main(float4 pos : POSITION, float2 uv : TEXCOORD0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = mul( float4(pos.x, pos.y, 0.0, 1.0), projection); 
	output.uv = pos.zw; 
	return output; 
} 
 
 
 
/* 
#version 330 core 
layout(location = 0) in vec4 vertex; // vec2 pos & vec2 texure coods 
out vec2 TexCoords; 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
    TexCoords = vertex.zw; 
}  
*/ 
¬
text_fs_Atlas.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s2); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
	float3 Colour : NORMAL; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	const float SampledValue = texColour.Sample(defaultSampler, input.uv).r; 
	float4 sampled = float4(1.0,1.0,1.0, SampledValue); 
	return float4(input.Colour, SampledValue); 
} 
¬
text_vs_Atlas.hlsl|FileStart|
 
cbuffer LineConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
} 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
	float3 Colour : NORMAL; 
}; 
 
 
VS_OUTPUT main(float4 pos : POSITION, float3 colour: NORMAL) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = mul( float4(pos.x, pos.y, 0.0, 1.0), projection); 
	output.uv = pos.zw; 
	output.Colour = colour; 
	return output; 
} 
 
 
 
/* 
#version 330 core 
layout(location = 0) in vec4 vertex; // vec2 pos & vec2 texure coods 
out vec2 TexCoords; 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
    TexCoords = vertex.zw; 
}  
*/ 
¬
