Compost_fs.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	//return float4(1,1,1,1); 
	float4 output = texColour.Sample(defaultSampler, input.uv); 
	//output.a = 0.25f; 
	return output; 
	 
} 
¬
DeferredWrite_fs.hlsl|FileStart|
Texture2D texColour : register( t0 ); 
SamplerState defaultSampler : register ( s0 ); 
 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float4 Normal :NORMAL0; 
	float2 uv : TEXCOORD; 
	float4 WorldPos:TANGENT0; 
}; 
struct FS_OUTPUT 
{ 
	float4 Gpos: SV_Target0; 
	float4 GNormal: SV_Target1; 
	float4 GAlbedoSpec: SV_Target2; 
	float4 GTangent: SV_Target3; 
}; 
FS_OUTPUT main(PSInput input )  
{ 
	FS_OUTPUT output = (FS_OUTPUT)0; 
	output.Gpos = input.WorldPos; 
	output.GNormal = float4(input.Normal.xyz,1.0f);//todo: remove this exta compoenent 
	output.GAlbedoSpec = float4(texColour.Sample(defaultSampler, input.uv).xyz, 1.0f); 
    return output; 
} 
¬
DeferredWrite_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register( b0 ) 
{ 
	row_major matrix world; 
	row_major matrix view; 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 normal : NORMAL0; 
	float3 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main( float4 pos : POSITION, float4 normal : NORMAL0, float3 uv : TEXCOORD0 ) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul( pos, world ); 
	result.WorldPos = final_pos; 
	final_pos = mul( final_pos, view ); 
	final_pos = mul( final_pos, projection ); 
 
	output.pos = final_pos; 
	output.normal = normal; 
	output.uv = uv; 
 
    return output; 
} 
¬
Deferred_LightingPass_fs.hlsl|FileStart|
Texture2D PosTexture : register(t0); 
Texture2D NormalTexture : register(t1); 
Texture2D AlbedoTexture : register(t2); 
SamplerState defaultSampler : register (s1); 
#define MAX_LIGHT 4 
struct Light 
{ 
	float3 LPosition; 
	float3 color; 
	float3 Direction; 
	row_major matrix LightVP; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
}; 
 
float4 CalcLightingColor(float3 MaterialDiffuseColor, float3 vLightPos, float3 vLightDir, float3 vLightColor, float4 vFalloffs, float3 vPosWorld, float3 vPerPixelNormal) 
{ 
 
	float diffu = max(dot(vPerPixelNormal, vLightDir), 0.0);//diffuse 
	float spec = 0.0f; 
	float3 viewPos = float3(0, 0, 0); 
	if (diffu > 0.0f) 
	{ 
		/*float3 viewDir = normalize(viewPos - vPosWorld); 
		float3 reflectDir = reflect(-lightdir, normal); 
		float spec = pow(max(dot(viewDir, reflectDir), 0.0f), 32);*/ 
	} 
	MaterialDiffuseColor *= vLightColor; 
 
	return  float4((MaterialDiffuseColor * diffu) /*+ (MaterialSpecularColor*spec)*/ , 1.0); 
} 
 
float3 Phong_Diffuse(float3 MaterialDiffuseColor, float3 LightDir, float3 Normal) 
{ 
	float diffu = max(dot(Normal, LightDir), 0.0);//diffuse 
	return MaterialDiffuseColor * diffu; 
} 
 
float3 GetAmbient() 
{ 
	return float3(0.2, 0.2, 0.2); 
} 
 
 
float3 CalcColorFromLight(Light light,float3 Diffusecolor,float3 FragPos,float3 normal) 
{ 
	float3 LightDirection = float3(0, 1, 0); 
	float distanceToLight = length(light.LPosition - FragPos); 
	float attenuation = 1.0 / (1.0 + 0.001 * pow(distanceToLight, 2)); 
 
	if (light.type == 1) 
	{ 
		LightDirection = normalize(light.LPosition - FragPos); 
	} 
	else 
	{ 
		LightDirection = -light.Direction; 
	} 
 
	float3 Diffusecolour = Phong_Diffuse(Diffusecolor, LightDirection, normal) * light.color; 
	return Diffusecolour *attenuation; 
} 
 
#define MAX_LIGHT 4 
 
cbuffer LightBuffer : register(b1) 
{ 
	Light lights[MAX_LIGHT]; 
}; 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	float4 pos = PosTexture.Sample(defaultSampler, input.uv); 
	float4 normal = NormalTexture.Sample(defaultSampler, input.uv); 
	float4 AlbedoSpec = AlbedoTexture.Sample(defaultSampler, input.uv); 
	float3 Diffusecolour = AlbedoSpec.xyz * GetAmbient(); 
	for (int i = 0; i < MAX_LIGHT; i++) 
	{ 
		Diffusecolour += CalcColorFromLight(lights[i], AlbedoSpec.xyz, pos.xyz, normalize(normal.xyz)); 
	} 
	return float4(Diffusecolour,1.0f); 
} 
¬
Deferred_LightingPass_vs.hlsl|FileStart|
 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 position : POSITION /*float4 normal : NORMAL0,*/ /*float4 uv : TEXCOORD*/) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = position; 
	const float2 fliped = float2 (position.x, -position.y); 
	output.uv = (fliped + float2(1, 1)) / 2.0f; 
	return output; 
} 
¬
Lighting.hlsl|FileStart|
#define MAX_LIGHT 4 
struct Light 
{ 
	float3 LPosition; 
	float3 color; 
	float3 Direction; 
	row_major matrix LightVP; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
}; 
 
float4 CalcLightingColor(float3 MaterialDiffuseColor, float3 vLightPos, float3 vLightDir, float3 vLightColor, float4 vFalloffs, float3 vPosWorld, float3 vPerPixelNormal) 
{ 
 
	float diffu = max(dot(vPerPixelNormal, vLightDir), 0.0);//diffuse 
	float spec = 0.0f; 
	float3 viewPos = float3(0, 0, 0); 
	if (diffu > 0.0f) 
	{ 
		/*float3 viewDir = normalize(viewPos - vPosWorld); 
		float3 reflectDir = reflect(-lightdir, normal); 
		float spec = pow(max(dot(viewDir, reflectDir), 0.0f), 32);*/ 
	} 
	MaterialDiffuseColor *= vLightColor; 
 
	return  float4((MaterialDiffuseColor * diffu) /*+ (MaterialSpecularColor*spec)*/ , 1.0); 
} 
 
float3 Phong_Diffuse(float3 MaterialDiffuseColor, float3 LightDir, float3 Normal) 
{ 
	float diffu = max(dot(Normal, LightDir), 0.0);//diffuse 
	return MaterialDiffuseColor * diffu; 
} 
 
float3 GetAmbient() 
{ 
	return float3(0.2, 0.2, 0.2); 
} 
 
 
float3 CalcColorFromLight(Light light,float3 Diffusecolor,float3 FragPos,float3 normal) 
{ 
	float3 LightDirection = float3(0, 1, 0); 
	float distanceToLight = length(light.LPosition - FragPos); 
	float attenuation = 1.0 / (1.0 + 0.001 * pow(distanceToLight, 2)); 
 
	if (light.type == 1) 
	{ 
		LightDirection = normalize(light.LPosition - FragPos); 
	} 
	else 
	{ 
		LightDirection = -light.Direction; 
	} 
 
	float3 Diffusecolour = Phong_Diffuse(Diffusecolor, LightDirection, normal) * light.color; 
	return Diffusecolour *attenuation; 
} 
¬
Main_fs.hlsl|FileStart|
Texture2D texColour : register( t0 ); 
SamplerState defaultSampler : register ( s0 ); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float4 normal : NORMAL0; 
	float3 uv : TEXCOORD0; 
}; 
 
float4 main( VS_OUTPUT input ) : SV_Target 
{ 
    return texColour.Sample( defaultSampler, input.uv ); 
} 
¬
Main_fs_12.hlsl|FileStart|
#define MAX_LIGHT 4 
struct Light 
{ 
	float3 LPosition; 
	float3 color; 
	float3 Direction; 
	row_major matrix LightVP; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
}; 
 
float4 CalcLightingColor(float3 MaterialDiffuseColor, float3 vLightPos, float3 vLightDir, float3 vLightColor, float4 vFalloffs, float3 vPosWorld, float3 vPerPixelNormal) 
{ 
 
	float diffu = max(dot(vPerPixelNormal, vLightDir), 0.0);//diffuse 
	float spec = 0.0f; 
	float3 viewPos = float3(0, 0, 0); 
	if (diffu > 0.0f) 
	{ 
		/*float3 viewDir = normalize(viewPos - vPosWorld); 
		float3 reflectDir = reflect(-lightdir, normal); 
		float spec = pow(max(dot(viewDir, reflectDir), 0.0f), 32);*/ 
	} 
	MaterialDiffuseColor *= vLightColor; 
 
	return  float4((MaterialDiffuseColor * diffu) /*+ (MaterialSpecularColor*spec)*/ , 1.0); 
} 
 
float3 Phong_Diffuse(float3 MaterialDiffuseColor, float3 LightDir, float3 Normal) 
{ 
	float diffu = max(dot(Normal, LightDir), 0.0);//diffuse 
	return MaterialDiffuseColor * diffu; 
} 
 
float3 GetAmbient() 
{ 
	return float3(0.2, 0.2, 0.2); 
} 
 
 
float3 CalcColorFromLight(Light light,float3 Diffusecolor,float3 FragPos,float3 normal) 
{ 
	float3 LightDirection = float3(0, 1, 0); 
	float distanceToLight = length(light.LPosition - FragPos); 
	float attenuation = 1.0 / (1.0 + 0.001 * pow(distanceToLight, 2)); 
 
	if (light.type == 1) 
	{ 
		LightDirection = normalize(light.LPosition - FragPos); 
	} 
	else 
	{ 
		LightDirection = -light.Direction; 
	} 
 
	float3 Diffusecolour = Phong_Diffuse(Diffusecolor, LightDirection, normal) * light.color; 
	return Diffusecolour *attenuation; 
} 
 
 
#define SHADOW_DEPTH_BIAS 0.005f 
cbuffer LightBuffer : register(b1) 
{ 
	Light lights[MAX_LIGHT]; 
}; 
 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float4 Normal :NORMAL0; 
	float2 uv : TEXCOORD0; 
	float4 WorldPos:TANGENT0; 
}; 
 
Texture2D g_texture : register(t0); 
 
Texture2D g_Shadow_texture : register(t1); 
//Texture2D g_Shadow_texture2 : register(t2); 
TextureCube g_Shadow_texture2 : register(t2); 
SamplerState g_sampler : register(s0); 
SamplerState g_Clampsampler : register(s1); 
float GetShadow(float4 pos) 
{ 
	float4 vLightSpacePos = pos; 
	//vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].view); 
	//vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].projection); 
	vLightSpacePos = mul(vLightSpacePos, lights[0].LightVP); 
	vLightSpacePos.xyz /= vLightSpacePos.w; 
	float2 vShadowTexCoord = 0.5f * vLightSpacePos.xy + 0.5f; 
	vShadowTexCoord.y = 1.0f - vShadowTexCoord.y; 
	float bias = 0.005; 
	if (g_Shadow_texture.Sample(g_sampler, vShadowTexCoord.xy).r < (vLightSpacePos.z - bias)) 
	{ 
		return 1.0f; 
	} 
	return 0.0f; 
} 
float4 CalcUnshadowedAmountPCF2x2(int lightid, float4 vPosWorld) 
{ 
	// Compute pixel position in light space. 
float4 vLightSpacePos = vPosWorld; 
vLightSpacePos = mul(vLightSpacePos, lights[lightid].LightVP); 
 
vLightSpacePos.xyz /= vLightSpacePos.w; 
 
// Translate from homogeneous coords to texture coords. 
float2 vShadowTexCoord = 0.5f * vLightSpacePos.xy + 0.5f; 
vShadowTexCoord.y = 1.0f - vShadowTexCoord.y; 
 
// Depth bias to avoid pixel self-shadowing. 
float vLightSpaceDepth = vLightSpacePos.z - SHADOW_DEPTH_BIAS; 
 
// Find sub-pixel weights.//todo: shader define! 
float2 vShadowMapDims = float2(1024, 1024); // need to keep in sync with .cpp file 
float size = 1.0f; 
float4 vSubPixelCoords = float4(size, size, size, size); 
vSubPixelCoords.xy = frac(vShadowMapDims * vShadowTexCoord); 
vSubPixelCoords.zw = 1.0f - vSubPixelCoords.xy; 
float4 vBilinearWeights = vSubPixelCoords.zxzx * vSubPixelCoords.wwyy; 
 
// 2x2 percentage closer filtering. 
float2 vTexelUnits = 1.0f / vShadowMapDims; 
float4 vShadowDepths; 
if (lightid == 0) 
{ 
	vShadowDepths.x = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord); 
	vShadowDepths.y = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
	vShadowDepths.z = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
	vShadowDepths.w = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits); 
} 
else 
{ 
	/*vShadowDepths.x = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord); 
	vShadowDepths.y = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
	vShadowDepths.z = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
	vShadowDepths.w = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits);*/ 
} 
// What weighted fraction of the 4 samples are nearer to the light than this pixel? 
float4 vShadowTests = (vShadowDepths >= vLightSpaceDepth) ? 1.0f : 0.0f; 
return dot(vBilinearWeights, vShadowTests); 
} 
float ShadowCalculationCube(const float3 fragPos, Light lpos); 
 
float4 main(PSInput input) : SV_TARGET 
{ 
 
	float3 texturecolour = g_texture.Sample(g_sampler, input.uv); 
	float3 output = float3(0, 0, 0); 
	for (int i = 0; i < MAX_LIGHT; i++) 
	{ 
		float3 colour = CalcColorFromLight(lights[i], texturecolour, input.WorldPos.xyz, normalize(input.Normal.xyz)); 
		if (lights[i].HasShadow && lights[i].type == 0) 
		{ 
			colour *= CalcUnshadowedAmountPCF2x2(i, input.WorldPos); 
		} 
		/*if (lights[i].HasShadow && lights[i].type == 0) 
		{ 
			colour = ShadowCalculationCube( input.WorldPos, lights[i]); 
		}*/ 
		output += colour; 
	} 
 
	float3 ambeint = texturecolour * GetAmbient(); 
	float Shadow = CalcUnshadowedAmountPCF2x2(0, input.WorldPos); 
	float3 GammaCorrected = ambeint + output; 
	float gamma = 1.0f / 2.2f; 
	//	GammaCorrected = pow(GammaCorrected, float4(gamma, gamma, gamma, gamma)); 
	return float4(GammaCorrected.xyz,1.0f); 
} 
 
 
float ShadowCalculationCube(const float3 fragPos, Light lpos) 
{ 
	// Get vector between fragment position and light position 
	float3 fragToLight = fragPos - float3(0, 5, 20);// lpos.LPosition; 
 
	float currentDepth = length(fragToLight); 
	//if (currentDepth > MaxShadowDistance) 
	//{ 
	//	//	return 0.0f; 
	//} 
	float shadow = 0.0f; 
	float bias = 0.01f; 
	int samples = 1; 
	/*float viewDistance = length(viewPos - fragPos); 
	float diskRadius = (1.0f + (viewDistance / far_plane)) / 25.0f;*/ 
	float far_plane = 500.0f; 
 
	float closestDepth = 0; 
	closestDepth = g_Shadow_texture2.Sample(g_Clampsampler, fragToLight).r; 
 
	closestDepth *= far_plane; 
	if (currentDepth - bias > closestDepth) 
	{ 
		return 1.0f; 
	} 
	 
	//shadow /= float(samples);//average of samples 
	//						 //cleanup the low shadow areas 
	/*if (shadow < 0.25f) 
	{ 
		return 0.0f; 
	}*/ 
	return 0.0f; 
} 
¬
Main_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register( b0 ) 
{ 
	row_major matrix world; 
	row_major matrix view; 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float4 normal : NORMAL0; 
	float3 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main( float4 pos : POSITION, float4 normal : NORMAL0, float3 uv : TEXCOORD0 ) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul( pos, world ); 
	 
	final_pos = mul( final_pos, view ); 
	final_pos = mul( final_pos, projection ); 
 
	output.pos = final_pos; 
	output.normal = normal; 
	output.uv = uv; 
 
    return output; 
} 
¬
Main_vs_12.hlsl|FileStart|
 
struct PSInput 
{ 
	float4 position : SV_POSITION; 
	float4 Normal :NORMAL0; 
	float2 uv : TEXCOORD; 
	float4 WorldPos:TANGENT0; 
}; 
 
Texture2D g_texture : register(t0); 
SamplerState g_sampler : register(s0); 
 
cbuffer GOConstantBuffer : register(b0) 
{ 
	row_major matrix Model; 
}; 
cbuffer SceneConstantBuffer : register(b2) 
{ 
	row_major matrix View; 
	row_major matrix Projection; 
}; 
 
PSInput main(float4 position : POSITION, float4 normal : NORMAL0, float4 uv : TEXCOORD) 
{ 
	PSInput result; 
	float4 final_pos = position; 
	final_pos.w = 1.0f; 
	final_pos = mul(position, Model); 
	result.WorldPos = final_pos; 
	final_pos = mul(final_pos, View); 
	final_pos = mul(final_pos, Projection); 
	result.position = final_pos; 
	result.uv = uv.xy; 
	result.Normal = normal; 
 
	return result; 
} 
¬
MipmapCS.hlsl|FileStart|
Texture2D<float4> SrcTexture : register(t0); 
RWTexture2D<float4> DstTexture : register(u0); 
SamplerState BilinearClamp : register(s0); 
 
cbuffer CB : register(b0) 
{ 
	float2 TexelSize;   // 1.0 / destination dimension 
} 
 
[numthreads(8, 8, 1)] 
void main(uint3 DTid : SV_DispatchThreadID) 
{ 
	//DTid is the thread ID * the values from numthreads above and in this case correspond to the pixels location in number of pixels. 
	//As a result texcoords (in 0-1 range) will point at the center between the 4 pixels used for the mipmap. 
	//TexelSize = 1.0 / 256; 
	//(1.0 / 256)  
	float2 texcoords = TexelSize * (DTid.xy + 0.5); 
 
	//The samplers linear interpolation will mix the four pixel values to the new pixels color 
	float4 color = SrcTexture.SampleLevel(BilinearClamp, texcoords, 0); 
 
	//Write the final color into the destination texture. 
	DstTexture[DTid.xy] = color; 
} 
¬
Pass_fs.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	return texColour.Sample(defaultSampler, input.uv); 
	//return float4(1,1,1,1); 
} 
¬
Pass_fs_12.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	//return float4(1,1,1,1); 
	float4 output = texColour.Sample(defaultSampler, input.uv); 
 
	float exposure = 2.5f; 
	float4 mapped = float4(1.0,1.0,1.0,1.0) - exp(-output * exposure); 
 
#if 0 
	float gamma = 1.0f / 2.2f; 
	output = pow(output, float4(gamma, gamma, gamma, gamma)); 
#endif 
	return mapped; 
	 
} 
¬
Pass_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix world; 
	row_major matrix view; 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 pos : POSITION, float3 uv : TEXCOORD0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul(pos, world); 
 
	//final_pos = mul(final_pos, view); 
	//final_pos = mul(final_pos, projection); 
 
	output.pos = final_pos; 
 
	//output.uv = uv; 
	float2 u = (pos.xy + float2(1, 1)) / 2.0; 
	output.uv = float3(u.x, -u.y, 0); 
	return output; 
} 
¬
Pass_vs_12.hlsl|FileStart|
 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 position : POSITION /*float4 normal : NORMAL0,*/ /*float4 uv : TEXCOORD*/) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
//	float4 final_pos = mul(position, world); 
// 
//	//final_pos = musssl(final_pos, view); 
//	//final_pos = mul(final_pos, projection); 
////	output.normal = float3(0, 0, -1); 
//	output.pos = float4(position.xy, 0, 10.0f); 
// 
//	//output.uv = uv; 
//	float2 u = (position.xy + float2(1, 1)) / 2.2; 
//	//output.uv = uv;// u;///float3(u.x, -u.y, 0); 
	 
	output.pos = position; 
	const float2 fliped = float2 (position.x, -position.y); 
	output.uv = (fliped + float2(1, 1)) / 2.0f; 
	return output; 
} 
¬
PostProcessBase_VS.hlsl|FileStart|
 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 position : POSITION /*float4 normal : NORMAL0,*/ /*float4 uv : TEXCOORD*/) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = position; 
	const float2 fliped = float2 (position.x, -position.y); 
	output.uv = (fliped + float2(1, 1)) / 2.0f; 
	return output; 
} 
¬
Shadow.hlsl|FileStart|
#define SHADOW_DEPTH_BIAS 0.005f 
loat4 CalcUnshadowedAmountPCF2x2(int lightid, float4 vPosWorld) 
{ 
	// Compute pixel position in light space. 
	float4 vLightSpacePos = vPosWorld; 
	vLightSpacePos = mul(vLightSpacePos, lights[lightid].LightVP); 
 
	vLightSpacePos.xyz /= vLightSpacePos.w; 
 
	// Translate from homogeneous coords to texture coords. 
	float2 vShadowTexCoord = 0.5f * vLightSpacePos.xy + 0.5f; 
	vShadowTexCoord.y = 1.0f - vShadowTexCoord.y; 
 
	// Depth bias to avoid pixel self-shadowing. 
	float vLightSpaceDepth = vLightSpacePos.z - SHADOW_DEPTH_BIAS; 
 
	// Find sub-pixel weights.//todo: shader define! 
	float2 vShadowMapDims = float2(1024, 1024); // need to keep in sync with .cpp file 
	float size = 1.0f; 
	float4 vSubPixelCoords = float4(size, size, size, size); 
	vSubPixelCoords.xy = frac(vShadowMapDims * vShadowTexCoord); 
	vSubPixelCoords.zw = 1.0f - vSubPixelCoords.xy; 
	float4 vBilinearWeights = vSubPixelCoords.zxzx * vSubPixelCoords.wwyy; 
 
	// 2x2 percentage closer filtering. 
	float2 vTexelUnits = 1.0f / vShadowMapDims; 
	float4 vShadowDepths; 
	if (lightid == 0) 
	{ 
		vShadowDepths.x = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord); 
		vShadowDepths.y = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
		vShadowDepths.z = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
		vShadowDepths.w = g_Shadow_texture.Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits); 
	} 
	else 
	{ 
		/*vShadowDepths.x = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord); 
		vShadowDepths.y = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(vTexelUnits.x, 0.0f)); 
		vShadowDepths.z = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + float2(0.0f, vTexelUnits.y)); 
		vShadowDepths.w = g_Shadow_texture2.Sample(g_Clampsampler, vShadowTexCoord + vTexelUnits);*/ 
	} 
	// What weighted fraction of the 4 samples are nearer to the light than this pixel? 
	float4 vShadowTests = (vShadowDepths >= vLightSpaceDepth) ? 1.0f : 0.0f; 
	return dot(vBilinearWeights, vShadowTests); 
} 
¬
UI_Batch_fs.hlsl|FileStart|
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 FrontColour:TEXCOORD; 
	float3 BackColour:TEXCOORD1; 
	uint Back : TEXCOORD2; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	if (input.Back == 0 ) 
	{ 
		return float4(input.FrontColour.xyz, 0.0); 
	} 
	else 
	{ 
		return float4(input.BackColour.xyz,0.0); 
	} 
	 
} 
¬
UI_Batch_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float3 FrontColour:TEXCOORD; 
	float3 BackColour:TEXCOORD1; 
	uint Back: TEXCOORD2; 
}; 
 
 
VS_OUTPUT main(float2 position : POSITION, uint back : TEXCOORD2, float3 fc : TEXCOORD, float3 bc : TEXCOORD1) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 finalpos = float4(position.xy, 0.0, 1.0); 
	output.pos = mul(finalpos, projection); 
	output.FrontColour = fc; 
	output.Back = back; 
	output.BackColour = bc;	 
	return output; 
} 
¬
depthbasic_fs.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float4 normal : NORMAL0; 
	float3 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	return texColour.Sample(defaultSampler, input.uv); 
} 
¬
depthbasic_fs_12.hlsl|FileStart|
//Texture2D texColour : register(t0); 
//SamplerState defaultSampler : register (s0); 
 
struct GSOutput 
{ 
	float4 Pos : SV_Position; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: NORMAL0; 
}; 
 
float4 main(GSOutput input) : SV_Target 
{ 
#if DIRECTIONAL 
	return float4(1,1,1,1); 
#else 
	float Farplane = 500.0f; 
	float LightDistance = length(input.Pos.xyz - input.LightPos); 
	LightDistance = LightDistance / Farplane; 
	return float4(LightDistance, LightDistance, LightDistance, LightDistance); 
 
#endif 
} 
 
 
#if 0 
struct FS_Output 
{ 
	float4 out1:SV_Target0; 
	float4 out2:SV_Target1; 
	float4 out3:SV_Target2; 
	float4 out4:SV_Target3; 
	float4 out5:SV_Target4; 
	float4 out6:SV_Target5; 
}; 
FS_Output main(VS_OUTPUT input) : SV_Target 
{ 
 
	FS_Output output = (FS_Output)0; 
	switch (input.slice) 
	{ 
	case 0: 
		output.out1 = float4(1, 1, 1, 1); 
		break; 
	case 1: 
		output.out2 = float4(1, 1, 1, 1); 
		break; 
	case 2: 
		output.out3 = float4(1, 1, 1, 1); 
		break; 
	case 3: 
		output.out4 = float4(1, 1, 1, 1); 
		break; 
	case 4: 
		output.out5 = float4(1, 1, 1, 1); 
		break; 
	case 5: 
		output.out6 = float4(1, 1, 1, 1); 
		break; 
	} 
	 
	return output; 
} 
#endif 
¬
depthbasic_geo.hlsl|FileStart|
cbuffer GeoTrans : register(b1) 
{ 
	row_major matrix worldm[6]; 
} 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: NORMAL0; 
}; 
 
struct GSOutput 
{ 
	float4 Pos : SV_POSITION; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: NORMAL0; 
}; 
 
[maxvertexcount(18)] 
void main(triangleadj VS_OUTPUT input[6], inout TriangleStream<GSOutput> OutputStream) 
{ 
	for (uint face = 0; face < 6; face += 1)//for each face 
	{ 
		GSOutput output = (GSOutput)0; 
		for (int i = 0; i < 3; ++i) // for each triangle's vertices 
		{ 
			output.Pos = mul(input[i].pos, worldm[face]); 
			output.slice = face; 
			output.LightPos = input[i].LightPos; 
			OutputStream.Append(output); 
		} 
		OutputStream.RestartStrip(); 
	} 
 
} 
 
¬
depthbasic_vs.hlsl|FileStart|
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix world; 
	row_major matrix view; 
	row_major matrix projection; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
}; 
 
 
VS_OUTPUT main(float4 pos : POSITION, float4 normal : NORMAL0, float3 uv : TEXCOORD0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul(pos, world); 
 
	final_pos = mul(final_pos, view); 
	final_pos = mul(final_pos, projection); 
 
	output.pos = final_pos; 
	output.normal = normal; 
	output.uv = uv; 
 
	return output; 
} 
¬
depthbasic_vs_12.hlsl|FileStart|
cbuffer ConstantBuffer : register(b0) 
{ 
	row_major matrix world; 
} 
 
cbuffer SceneConstantBuffer : register(b2) 
{ 
	row_major matrix ViewP; 
	row_major matrix Projection; 
}; 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	uint slice : SV_RenderTargetArrayIndex; 
	float3 LightPos: NORMAL0; 
}; 
 
 
VS_OUTPUT main(float4 pos : POSITION, float4 normal : NORMAL0, float3 uv : TEXCOORD0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	float4 final_pos = mul(pos, world); 
#if DIRECTIONAL 
	final_pos = mul(final_pos, ViewP); 
	final_pos = mul(final_pos, Projection); 
#endif 
	output.pos = final_pos; 
	output.LightPos = float3(0, 5, 20); 
	return output; 
} 
¬
output_fs.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s0); 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	return texColour.Sample(defaultSampler, input.uv); 
//return float4(1,1,1,1); 
} 
¬
output_vs.hlsl|FileStart|
 
cbuffer LineConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
	float3 Colour; 
} 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
VS_OUTPUT main(float4 pos : POSITION, float2 uv : TEXCOORD0) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = mul( float4(pos.x, pos.y, 0.0, 1.0), projection); 
	output.uv = pos.zw; 
	return output; 
} 
 
 
 
/* 
#version 330 core 
layout(location = 0) in vec4 vertex; // vec2 pos & vec2 texure coods 
out vec2 TexCoords; 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
    TexCoords = vertex.zw; 
}  
*/ 
¬
text_fs_Atlas.hlsl|FileStart|
Texture2D texColour : register(t0); 
SamplerState defaultSampler : register (s2); 
 
cbuffer LineConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
	float3 Colour; 
} 
 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
float4 main(VS_OUTPUT input) : SV_Target 
{ 
	//return float4(Colour,1.0); 
	//float sampled = texColour.Sample(defaultSampler, input.uv).rgba; 
	//return texColour.Sample(defaultSampler, input.uv).rgba;// float4(sampled, sampled, sampled, sampled); 
	const float SampledValue = texColour.Sample(defaultSampler, input.uv).r; 
	float4 sampled = float4(1.0,1.0,1.0, SampledValue); 
	return float4(Colour, SampledValue); 
} 
¬
text_vs_Atlas.hlsl|FileStart|
 
cbuffer LineConstantBuffer : register(b0) 
{ 
	row_major matrix projection; 
	float3 Colour; 
} 
struct VS_OUTPUT 
{ 
	float4 pos : SV_POSITION; 
	float2 uv : TEXCOORD0; 
}; 
 
 
VS_OUTPUT main(float4 pos : POSITION) 
{ 
	VS_OUTPUT output = (VS_OUTPUT)0; 
	output.pos = mul( float4(pos.x, pos.y, 0.0, 1.0), projection); 
	output.uv = pos.zw; 
	return output; 
} 
 
 
 
/* 
#version 330 core 
layout(location = 0) in vec4 vertex; // vec2 pos & vec2 texure coods 
out vec2 TexCoords; 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
    TexCoords = vertex.zw; 
}  
*/ 
¬
