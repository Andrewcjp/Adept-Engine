Deferred.frag|
#version 330 core 
out vec4 FragColor; 
in vec2 TexCoords; 
vec2 Itexcorrds; 
uniform sampler2D gPosition; 
uniform sampler2D gNormal; 
uniform sampler2D gAlbedoSpec; 
uniform sampler2D ssao; 
uniform sampler2D gTangent; 
uniform float far_plane; 
uniform vec3 viewPos; 
mat3 TBN; 
vec3 WorldPos; 
 
#define MAX_LIGHTS 5 
uniform int numLights; 
uniform struct Light { 
    vec3 position; 
    vec3 Color; 
	vec3 Direction; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
	//sampler2D Shadowflat; 
	//samplerCube shadowcubemap; 
}allLights[MAX_LIGHTS]; 
 
vec3 CalculateColour(vec3 normal,vec3 lightdir,vec3 MaterialDiffuseColor,vec3 MaterialSpecularColor){ 
	float diffu = max(dot( normal,lightdir),0.0);//diffuse 
	float spec  = 0.0f;	 
	if(diffu > 0.0f){ 
		vec3 viewDir = normalize(viewPos - WorldPos); 
		vec3 reflectDir = reflect(-lightdir, normal);   
		float spec = pow(max(dot(viewDir, reflectDir), 0.0f), 32);		 
	} 
	return (MaterialDiffuseColor * diffu) +( MaterialSpecularColor*spec); 
} 
 
 
 
 
int MaxShadowDistance = 100; 
uniform samplerCube shadowcubemap; 
uniform samplerCube shadowcubemap2; 
uniform sampler2D shadowdirmap; 
uniform sampler2D shadowdirma2; 
uniform sampler2D shadowdirmap3; 
uniform sampler2D shadowdirmap4; 
 
vec3 gridSamplingDisk[20] = vec3[] 
( 
   vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1),  
   vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1), 
   vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0), 
   vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1), 
   vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1) 
); 
 
 
float ShadowCalculationCube(const vec3 fragPos,Light lpos){ 
    // Get vector between fragment position and light position 
    vec3 fragToLight = fragPos - lpos.position; 
	 
    float currentDepth = length(fragToLight); 
	if(currentDepth > MaxShadowDistance){ 
	//	return 0.0f; 
	} 
    float shadow = 0.0f; 
    float bias = 0.09f; 
    int samples = 20; 
    float viewDistance = length(viewPos - fragPos); 
    float diskRadius = (1.0f + (viewDistance / far_plane)) / 25.0f; 
    for(int i = 0; i < samples; ++i) 
    { 
		float closestDepth = 0; 
		if(lpos.ShadowID == 0){ 
		 closestDepth = texture(shadowcubemap, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
		}else if(lpos.ShadowID == 1){ 
		 closestDepth = texture(shadowcubemap2, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
		} 
		 
        closestDepth *= far_plane;    
        if(currentDepth - bias > closestDepth) 
            shadow += 1.0f; 
    } 
    shadow /= float(samples);//average of samples 
	//cleanup the low shadow areas 
	if(shadow < 0.25f){ 
		return 0.0f; 
	} 
    return shadow; 
} 
 
float ShadowCalculationDir(const vec3 fragPos, Light lpos){ 
     vec3 fragToLight = lpos.Direction;//fragPos - lpos.position; 
//	vec3 fragToLight = fragPos - allLights[0].position; 
     float currentDepth = fragPos.z;//length(fragToLight); 
	 vec2 coords = fragPos.xy; 
 
	 
	//float closestDepth = texture(shadowdirmap,fragToLight.xy).r; 
	if(texture( shadowdirmap, fragPos.xy ).z  <  fragPos.z){ 
		return 1.0f; 
	} 
    return 0.0f; 
 
} 
 
 
const int TYPE_DIRECTIONAL = 0; 
const int TYPE_POINT = 1; 
const int TYPE_SPOT = 2; 
 
 
void main() 
{         
    // Retrieve data from gbuffer 
    vec3 FragPos = texture(gPosition, TexCoords).rgb; 
	WorldPos = FragPos; 
    vec3 Normal = normalize(texture(gNormal, TexCoords).rgb); 
    vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb; 
    float Specular = texture(gAlbedoSpec, TexCoords).a; 
	float AmbientOcclusion = texture(ssao, TexCoords).r; 
	vec3 Tangent = texture(gTangent, TexCoords).rgb; 
	//consruct the tbn matrix 
	vec3 vtangent = normalize(Tangent); 
    vec3 vbitangent = normalize(cross(Normal,Tangent)); 
    vec3 vnormal = normalize( Normal); 
    // re-orthogonalize T with respect to N 
	vtangent = normalize(vtangent - dot(vtangent, vnormal) * vnormal); 
    vbitangent = cross(vtangent,vnormal); 
	 
	 TBN = transpose(mat3( 
		vtangent, 
		vbitangent, 
		vnormal	 
	)); 
  
    vec3 lighting = Diffuse * 0.2 * AmbientOcclusion;  
    vec3 viewDir  = normalize(viewPos - FragPos); 
	//viewDir = normalize(-FragPos); 
    for(int i = 0; i < numLights; ++i) 
    { 
         
        vec3 lightDir = normalize(allLights[i].position - FragPos); 
		Diffuse *=allLights[i].Color; 
		 
		//old 
     //   vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * allLights[i].Color;		 
	//	vec3 reflectDir = reflect(-lightDir, Normal);   
	//	float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16); 
		 
       vec3 specularcol = allLights[i].Color  * Specular; 
         
       float distance = length(allLights[i].position - FragPos); 
 
	   float attenuation = 1; 
	   if(allLights[i].type != TYPE_DIRECTIONAL){ 
			attenuation = 1.0/(distance*distance); 
	   }	    
	   float vis = 1.0; 
	   if(allLights[i].HasShadow == 1 ){ 
		 vis = 1.0 - ShadowCalculationCube(FragPos,allLights[i]); 
	   } 
	   //vis = 1; 
       lighting += ((CalculateColour(Normal,lightDir,Diffuse,specularcol)*attenuation)*vis); 
	//	lighting  =vec3(AmbientOcclusion); 
    }     
	 
 
	vec3 colorGammaCorrected = pow(lighting, vec3(1.0/2.2));//apply gamma correction 
    FragColor = vec4(colorGammaCorrected, 1.0); 
} 
¬
Deferred.vert|
#version 330 core 
layout (location = 0) in vec3 pos; 
layout (location = 1) in vec3 normal; 
layout (location = 2) in vec2 texCoords; 
 
out vec2 TexCoords; 
 
 
void main(){ 
    //TexCoords = texCoords; 
	TexCoords = (pos.xy+vec2(1,1))/2.0; 
    gl_Position =  vec4(pos, 1.0);	 
} 
¬
DeferredWrite.frag|
#version 330 core 
layout (location = 0) out vec3 gPosition; 
layout (location = 1) out vec3 gNormal; 
layout (location = 2) out vec4 gAlbedoSpec; 
layout (location = 3) out vec3 gTangent; 
 
in vec2 TexCoords; 
in vec3 WorldPos; 
in vec3 Normal; 
in vec3 Tangent; 
in mat3 TBN; 
uniform sampler2D albedoMap; 
uniform sampler2D texture_specular1; 
uniform sampler2D NormalMap; 
uniform sampler2D Displacementmap; 
uniform int HasNormalMap; 
uniform vec3 campos; 
float height_scale = 0.06; 
vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir) 
{  
	viewDir = viewDir * TBN; 
	 
    float height = (texture(Displacementmap, texCoords.xy).r * height_scale);// - (height_scale/2.0);  //bias   
	 
    return texCoords.xy + viewDir.xy * height;     
}  
void main() 
{     
     
    gPosition = WorldPos; 
	vec2 newtexcoords = ParallaxMapping(TexCoords, normalize (campos - WorldPos));	 
	vec3 TextureNormal = (TBN*(texture( NormalMap, newtexcoords ).rgb*2-1)); 
	if(HasNormalMap == 1){ 
	 gNormal = normalize(TextureNormal); 
	 gAlbedoSpec.rgb = texture(albedoMap, newtexcoords).rgb; 
	}else{		 
	 gNormal = normalize(Normal); 
	 gAlbedoSpec.rgb = texture(albedoMap,TexCoords ).rgb; 
	}	 
	gTangent = Tangent; 
     
	gAlbedoSpec.a = 0.1; 
}   
¬
DeferredWrite.vert|
#version 420 core 
layout (location = 0) in vec3 pos; 
layout (location = 1) in vec3 normal; 
layout (location = 2) in vec2 texCoords; 
layout (location = 3) in vec3 Vtangent; 
 
out vec2 TexCoords; 
out vec3 WorldPos; 
out vec3 Normal; 
out vec3 Tangent; 
out mat3 TBN; 
uniform mat4 projection; 
uniform mat4 view; 
uniform mat4 model; 
 
void main(){ 
 
    TexCoords = texCoords; 
 
    WorldPos = (model * vec4(pos, 1.0)).xyz; 
	Normal = normalize((model * vec4(normal,0.0)).xyz);	 
 
    gl_Position =  projection *view * model* vec4(pos, 1.0);	 
	Tangent = normalize(mat3(model) * Vtangent); 
	//create the TBN matrix  
	vec3 vtangent = normalize(Tangent); 
    vec3 vbitangent = normalize(cross(Normal,Tangent)); 
    vec3 vnormal = normalize( Normal); 
	 
    // re-orthogonalize T with respect to N 
	vtangent = normalize(vtangent - dot(vtangent, vnormal) * vnormal); 
    vbitangent = cross(vtangent,vnormal); 
	 
	 TBN = transpose(mat3( 
		vtangent, 
		vbitangent, 
		vnormal	 
	)); 
		 
	 
} 
¬
Grass.frag|
#version 330 
 
in vec2 vTexCoord; 
//smooth in vec3 vNormal; 
 
 
out vec4 outputColor; 
 
uniform sampler2D gSampler; 
uniform vec4 vColor; 
 
uniform vec3 vEyePosition; 
 
//uniform Material matActive; 
 
uniform float fAlphaTest; 
uniform float fAlphaMultiplier; 
uniform vec3 Colour; 
void main() 
{ 
	vec4 vTexColor = texture2D(gSampler, vTexCoord); 
	float fNewAlpha = vTexColor.a*fAlphaMultiplier;                
	if(fNewAlpha < fAlphaTest) 
		discard; 
	 
	if(fNewAlpha > 1.0f) 
		fNewAlpha = 1.0f;	 
		 
	vec4 vMixedColor =vTexColor; //mix(vTexColor,vec4(color,1.0),0.5) ;  
	 
	outputColor = vec4(vMixedColor.xyz, fNewAlpha); 
//	outputColor = vec4(color,fNewAlpha); 
	//outputColor = texture2D(gSampler, vTexCoord); 
	//outputColor = vec4(1,1,1,1); 
	//outputColor.a = 1.0f; 
} 
¬
Grass.geo|
#version 330 
 
layout(points) in; 
layout(triangle_strip) out; 
layout(max_vertices = 12) out; 
 
uniform mat4 projMatrix; 
uniform mat4 modelMatrix; 
uniform mat4 viewMatrix;                                                                            
uniform mat4 normalMatrix; 
 
 
smooth out vec2 vTexCoord; 
smooth out vec3 vWorldPos; 
smooth out vec4 vEyeSpacePos; 
 
uniform float fTimePassed; 
 
mat4 rotationMatrix(vec3 axis, float angle) 
{ 
    axis = normalize(axis); 
    float s = sin(angle); 
    float c = cos(angle); 
    float oc = 1.0 - c; 
     
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0, 
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0, 
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0, 
                0.0,                                0.0,                                0.0,                                1.0); 
} 
 
vec3 vLocalSeed; 
 
// This function returns random number from zero to one 
float randZeroOne() 
{ 
    uint n = floatBitsToUint(vLocalSeed.y * 214013.0 + vLocalSeed.x * 2531011.0 + vLocalSeed.z * 141251.0); 
    n = n * (n * n * 15731u + 789221u); 
    n = (n >> 9u) | 0x3F800000u; 
  
    float fRes =  2.0 - uintBitsToFloat(n); 
    vLocalSeed = vec3(vLocalSeed.x + 147158.0 * fRes, vLocalSeed.y*fRes  + 415161.0 * fRes, vLocalSeed.z + 324154.0*fRes); 
    return fRes; 
} 
 
int randomInt(int min, int max) 
{ 
	float fRandomFloat = randZeroOne(); 
	return int(float(min)+fRandomFloat*float(max-min)); 
} 
 
void main() 
{ 
	mat4 mMV = viewMatrix * modelMatrix;   
	mat4 mMVP = projMatrix * viewMatrix * modelMatrix; 
	 
	vec3 vGrassFieldPos = gl_in[0].gl_Position.xyz; 
 
	float PIover180 = 3.1415/180.0; 
	vec3 vBaseDir[3]; 
	vBaseDir[0] = vec3(1.0, 0.0, 0.0); 
	vBaseDir[1] = vec3(float(cos(45.0*PIover180)), 0.0f, float(sin(45.0*PIover180))); 
	vBaseDir[2] =vec3(float(cos(-45.0*PIover180)), 0.0f, float(sin(-45.0*PIover180))); 
	 
	float fGrassPatchSize = 5.0; 
	float fWindStrength = 4.0; 
	 
	vec3 vWindDirection = vec3(1.0, 0.0, 1.0); 
	vWindDirection = normalize(vWindDirection); 
	 
	for(int i = 0; i < 3; i++) 
	{ 
		// Grass patch top left vertex 
		 
		vec3 vBaseDirRotated = (rotationMatrix(vec3(0, 1, 0), sin(fTimePassed*0.7f)*0.1f)*vec4(vBaseDir[i], 1.0)).xyz; 
 
		vLocalSeed = vGrassFieldPos*float(i); 
		int iGrassPatch = randomInt(0, 3); 
		 
		float fGrassPatchHeight = 3.5+randZeroOne()*2.0; 
	 
		float fTCStartX = float(iGrassPatch)*0.25f; 
		float fTCEndX = fTCStartX+0.25f; 
		 
		float fWindPower = 0.5f+sin(vGrassFieldPos.x/30+vGrassFieldPos.z/30+fTimePassed*(1.2f+fWindStrength/20.0f)); 
		if(fWindPower < 0.0f) 
			fWindPower = fWindPower*0.2f; 
		else fWindPower = fWindPower*0.3f; 
		 
		fWindPower *= fWindStrength; 
		 
		vec3 vTL = vGrassFieldPos - vBaseDirRotated*fGrassPatchSize*0.5f + vWindDirection*fWindPower; 
		vTL.y += fGrassPatchHeight;    
		gl_Position = mMVP*vec4(vTL, 1.0); 
		vTexCoord = vec2(fTCStartX, 1.0); 
		vWorldPos = vTL; 
		vEyeSpacePos = mMV*vec4(vTL, 1.0); 
		EmitVertex(); 
		 
		// Grass patch bottom left vertex 
		vec3 vBL = vGrassFieldPos - vBaseDir[i]*fGrassPatchSize*0.5f;   
		gl_Position = mMVP*vec4(vBL, 1.0); 
		vTexCoord = vec2(fTCStartX, 0.0); 
		vWorldPos = vBL; 
		vEyeSpacePos = mMV*vec4(vBL, 1.0); 
		EmitVertex(); 
		                                
		// Grass patch top right vertex 
		vec3 vTR = vGrassFieldPos + vBaseDirRotated*fGrassPatchSize*0.5f + vWindDirection*fWindPower; 
		vTR.y += fGrassPatchHeight;   
		gl_Position = mMVP*vec4(vTR, 1.0); 
		vTexCoord = vec2(fTCEndX, 1.0); 
		vWorldPos = vTR; 
		vEyeSpacePos = mMV*vec4(vTR, 1.0); 
		EmitVertex(); 
		 
		// Grass patch bottom right vertex 
		vec3 vBR = vGrassFieldPos + vBaseDir[i]*fGrassPatchSize*0.5f;   
		gl_Position = mMVP*vec4(vBR, 1.0); 
		vTexCoord = vec2(fTCEndX, 0.0); 
		vWorldPos = vBR; 
		vEyeSpacePos = mMV*vec4(vBR, 1.0); 
		EmitVertex(); 
		 
		EndPrimitive(); 
	}		 
 
} 
¬
Grass.vert|
#version 450 
 
layout (location = 0) in vec3 inPosition; 
layout (location = 2) in vec2 inuv; 
layout (location = 5) in vec2 vpos; 
layout (location = 7) in vec3 colour; 
 
uniform mat4 projMatrix; 
uniform mat4 modelMatrix; 
uniform mat4 viewMatrix;                                                                            
uniform mat4 normalMatrix; 
vec4 adjustedpos; 
out vec2 vTexCoord; 
#define MAXInstances 200 
#define MAXUniqueRotations 200 
 
uniform mat4 Rotations[MAXInstances]; 
/*uniform RotBuffer 
{  
  mat4 urot; 
}UBufferRot[1];*/ 
out vec3 color; 
int instid = 0; 
 
void main() 
{ 
	vTexCoord = inuv; 
	 
	instid = gl_InstanceID; 
	/*if(gl_InstanceID > MAXUniqueRotations){			 
			instid = int(MAXUniqueRotations* sin(gl_InstanceID - MAXUniqueRotations));			 
			//repeat the values so that grass is animated at a lower cost 
			// if wind is added this system becmoes usless as only wind position and force would be passed to the shader a few times (array) 
			//rather than an entire mat4x4 for each grass object. 
	}*/ 
	if(gl_InstanceID > MAXUniqueRotations) 
	{			 
			instid = int(MAXUniqueRotations* sin(gl_InstanceID - MAXUniqueRotations));			 
	} 
	instid = clamp(instid,0,MAXUniqueRotations-1); 
 
	//adjustedpos = vec4(inPosition,1.0)*Rotations[instid] + vec4(Transforms[gl_InstanceID].x, 0, Transforms[gl_InstanceID].y,1.0); 
	 
	adjustedpos = (vec4(inPosition,1.0)*Rotations[instid]) + vec4(vpos.x, 0.0, vpos.y,1.0); 
	 
	gl_Position =  projMatrix * viewMatrix * modelMatrix * vec4(adjustedpos); 
 
} 
¬
Lighting.glh|
 
#define MAX_LIGHTS 5 
uniform int numLights; 
uniform struct Light { 
    vec3 position; 
    vec3 Color; 
	vec3 Direction; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
	//sampler2D Shadowflat; 
	//samplerCube shadowcubemap; 
}allLights[MAX_LIGHTS]; 
 
vec3 CalculateColour(vec3 normal,vec3 lightdir,vec3 MaterialDiffuseColor,vec3 MaterialSpecularColor){ 
	float diffu = max(dot( normal,lightdir),0.0);//diffuse 
	float spec  = 0.0f;	 
	if(diffu > 0.0f){ 
		vec3 viewDir = normalize(viewPos - WorldPos); 
		vec3 reflectDir = reflect(-lightdir, normal);   
		float spec = pow(max(dot(viewDir, reflectDir), 0.0f), 32);		 
	} 
	return (MaterialDiffuseColor * diffu) +( MaterialSpecularColor*spec); 
} 
 
 
¬
Main_fs.frag|
#version 420 core 
 
 
out vec4 FragColor; 
in vec2 TexCoords; 
in vec3 WorldPos; 
in vec3 Normal; 
in mat3 TBN; 
in vec4 PositionLightSpace; 
in vec3 EyeDirection_cameraspace; 
in vec3 TangentViewPos;  
in vec3 TangentFragPos; 
in vec4 ShadowCoord; 
// material parameters 
uniform sampler2D albedoMap; 
 
uniform float far_plane; 
uniform int isMap; 
uniform int HasNormal; 
uniform bool HasDisp; 
uniform mat4 view; 
uniform sampler2D NormalMap; 
uniform sampler2D Displacementmap; 
uniform mat4 model; 
in vec3 tangentdbg; 
int MaxDistance = 500; 
uniform vec3 viewPos; 
 
#define MAX_LIGHTS 5 
uniform int numLights; 
uniform struct Light { 
    vec3 position; 
    vec3 Color; 
	vec3 Direction; 
	int type;//type 1 == point, type 0 == directional, tpye 2 == spot 
	int ShadowID; 
	int DirShadowID; 
	int HasShadow; 
	//sampler2D Shadowflat; 
	//samplerCube shadowcubemap; 
}allLights[MAX_LIGHTS]; 
 
vec3 CalculateColour(vec3 normal,vec3 lightdir,vec3 MaterialDiffuseColor,vec3 MaterialSpecularColor){ 
	float diffu = max(dot( normal,lightdir),0.0);//diffuse 
	float spec  = 0.0f;	 
	if(diffu > 0.0f){ 
		vec3 viewDir = normalize(viewPos - WorldPos); 
		vec3 reflectDir = reflect(-lightdir, normal);   
		float spec = pow(max(dot(viewDir, reflectDir), 0.0f), 32);		 
	} 
	return (MaterialDiffuseColor * diffu) +( MaterialSpecularColor*spec); 
} 
 
 
 
 
const int TYPE_DIRECTIONAL = 0; 
const int TYPE_POINT = 1; 
const int TYPE_SPOT = 2; 
 
 
// lights 
 
vec3 albedo; 
float height_scale = 0.06;//make a uniform! 
float ShadowCalculationCube(const vec3 fragPos, Light lpos); 
float ShadowCalculationDir(const vec3 fragPos, Light lpos); 
vec2 PTexCoords; 
vec3 TSviewDir; 
vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir); 
float GetFogAmt(const float dist); 
 
uniform int VisShadow; 
uniform int FULLBRIGHT; 
uniform int IsWater; 
float Fogstart = 10.0f; 
float fogend = 100.0f; 
float FDensity = 0.05f; 
uniform float scroll; 
 
int MaxShadowDistance = 100; 
uniform samplerCube shadowcubemap; 
uniform samplerCube shadowcubemap2; 
uniform sampler2D shadowdirmap; 
uniform sampler2D shadowdirma2; 
uniform sampler2D shadowdirmap3; 
uniform sampler2D shadowdirmap4; 
 
vec3 gridSamplingDisk[20] = vec3[] 
( 
   vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1),  
   vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1), 
   vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0), 
   vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1), 
   vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1) 
); 
 
 
float ShadowCalculationCube(const vec3 fragPos,Light lpos){ 
    // Get vector between fragment position and light position 
    vec3 fragToLight = fragPos - lpos.position; 
	 
    float currentDepth = length(fragToLight); 
	if(currentDepth > MaxShadowDistance){ 
	//	return 0.0f; 
	} 
    float shadow = 0.0f; 
    float bias = 0.09f; 
    int samples = 20; 
    float viewDistance = length(viewPos - fragPos); 
    float diskRadius = (1.0f + (viewDistance / far_plane)) / 25.0f; 
    for(int i = 0; i < samples; ++i) 
    { 
		float closestDepth = 0; 
		if(lpos.ShadowID == 0){ 
		 closestDepth = texture(shadowcubemap, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
		}else if(lpos.ShadowID == 1){ 
		 closestDepth = texture(shadowcubemap2, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
		} 
		 
        closestDepth *= far_plane;    
        if(currentDepth - bias > closestDepth) 
            shadow += 1.0f; 
    } 
    shadow /= float(samples);//average of samples 
	//cleanup the low shadow areas 
	if(shadow < 0.25f){ 
		return 0.0f; 
	} 
    return shadow; 
} 
 
float ShadowCalculationDir(const vec3 fragPos, Light lpos){ 
     vec3 fragToLight = lpos.Direction;//fragPos - lpos.position; 
//	vec3 fragToLight = fragPos - allLights[0].position; 
     float currentDepth = fragPos.z;//length(fragToLight); 
	 vec2 coords = fragPos.xy; 
 
	 
	//float closestDepth = texture(shadowdirmap,fragToLight.xy).r; 
	if(texture( shadowdirmap, fragPos.xy ).z  <  fragPos.z){ 
		return 1.0f; 
	} 
    return 0.0f; 
 
} 
 
 
vec3 ApplyLight(Light light,vec3 MaterialDiffuseColor,vec3 MaterialSpecularColor,int number){ 
   
	vec3 TextureNormal_tangentspace = normalize(TBN * (texture( NormalMap, PTexCoords ).rgb*2-1));//from tangent space to camera space 
 
	float distance = length( light.position - WorldPos ); 
	if(distance > MaxDistance){ 
		return vec3(0,0,0); 
	} 
	 
	vec3 n = normalize(TextureNormal_tangentspace); 
	if(HasNormal == 0){ 
		n = normalize(Normal);	 
	} 
	//lighting  
	vec3 lightdir = normalize(light.position  - WorldPos);	 
	if(light.type == TYPE_DIRECTIONAL){ 
		lightdir = normalize(light.Direction); 
	} 
    //shadows 
	float visibility = 1.0f; 
	if(light.HasShadow == 1){	 
		visibility = 1.0f - ShadowCalculationCube(WorldPos,light); 
		if(light.type == TYPE_DIRECTIONAL){ 
		visibility = 1.0f - ShadowCalculationDir(WorldPos,light); 
		} 
	} 
	float Attuation = 1; 
	if(light.type != TYPE_DIRECTIONAL){ 
		Attuation = (distance*distance); 
	} 
	vec3 output = 	(visibility * CalculateColour(n,lightdir,MaterialDiffuseColor,MaterialSpecularColor) * light.Color) / Attuation; 
	output = clamp(output,0,1); 
 
    return output; 
} 
 
 
void main() 
{			 
	 
	if(HasDisp == false){ 
		PTexCoords = TexCoords; 
	} 
	else 
	{	 
		PTexCoords = ParallaxMapping(TexCoords, normalize(viewPos - WorldPos)); 
	} 
	if(isMap == 0){ 
		albedo = texture(albedoMap, PTexCoords).rgb; 
	}else{ 
		albedo = vec3(0,1,1); 
	} 
	if(IsWater == 1){ 
		//albedo = mix(albedo,vec3(0,0.8,1),0.25); 
		PTexCoords += vec2(0,scroll); 
	} 
	vec3 MaterialAmbientColor = vec3(0.1) * albedo; 
 
	vec3 linearColor = vec3(0); 
   for(int i = 0; i < numLights; ++i){ 
        linearColor += ApplyLight(allLights[i],albedo,vec3(0.1f),i); 
    } 
	linearColor = clamp(linearColor,0,1); 
	 
	 vec3 colorGammaCorrected = pow(linearColor, vec3(1.0f/2.2f));//apply gamma correction 
    vec3 color = 		 
		MaterialAmbientColor + colorGammaCorrected; 
	vec4 eyespacepos = view * vec4(WorldPos,1.0f); 
	 
	 
	if(FULLBRIGHT == 1){ 
		//color = MaterialDiffuseColor; 
	} 
	if(VisShadow == 1){ 
	//	color = vec3(visibility); 
	} 
	//fog  
	 
//	color = mix(color,vec3(0.4,0.4,0.4),GetFogAmt(abs(eyespacepos.z/eyespacepos.w))); 
 
    FragColor = vec4(color, texture(albedoMap, PTexCoords).a); 
} 
 
//paralax mappin 
vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir) 
{  
	viewDir = viewDir * TBN;//convert to Tanget space from camera space		 
    float height = (texture(Displacementmap, texCoords.xy).r * height_scale);// - (height_scale/2.0);  //bias  	 
    return texCoords.xy + viewDir.xy * height;     
}  
float GetFogAmt(const float dist){ 
	//float result = (fogend-dist)/(fogend-Fogstart);  	 
	const float result = exp(-FDensity*dist);  
	return 1.0f - clamp(result, 0.0f, 1.0f);  
} 
 
 
 
 
 
 
 
 
 
 
//float ShadowCalculationDir(const vec3 fragPos, Light lpos){ 
 // const   vec3 fragToLight = lpos.Direction;//fragPos - lpos.position; 
////	vec3 fragToLight = fragPos - allLights[0].position; 
//    const float currentDepth = fragPos.z;//length(fragToLight); 
//	const vec2 coords = fragPos.xy; 
//    float shadow = 0.0f; 
 //   const float bias = 0.05f; 
//   const  int samples = 20; 
//   const  float viewDistance = length(viewPos - fragPos); 
//   const  float diskRadius = (1.0 + (viewDistance / far_plane)) / 25.0f; 
//    for(int i = 0; i < samples; ++i) 
 //   { 
//	//	float closestDepth = texture(lpos.Shadowflat, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
//	if(lpos.DirShadowID == 0){ 
//		 closestDepth = texture(shadowcubemap, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
//		}else if(lpos.DirShadowID == 1){ 
//		 closestDepth = texture(shadowcubemap2, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
//		} 
	 
//	float closestDepth = texture(shadowdirmap,fragToLight.xy).r; 
		 
   // closestDepth *= far_plane;    
 //       if(currentDepth - bias > closestDepth) 
 // //         shadow += 1.0f; 
//} 
   // shadow /= float(samples);//average of samples 
	//cleanup the low shadow areas 
//	if(shadow < 0.25f){ 
		//return 0.0f; 
	//} 
	 
//	float closestDepth = texture(shadowdirmap,fragToLight.xy).r; 
	 
 //   return closestDepth; 
 
// 
 
 
 
¬
Main_vs.vert|
#version 420 core 
layout (location = 0) in vec3 pos; 
layout (location = 1) in vec3 normal; 
layout (location = 2) in vec2 texCoords; 
layout (location = 3) in vec3 vertexTangent_modelspace; 
layout (location = 4) in vec3 vertexBitangent_modelspace;  
 
layout (std140,binding = 1)uniform UBuffer 
{  
  mat4 model; 
  mat4 view; 
  mat4 projection; 
}; 
out vec2 TexCoords; 
out vec3 WorldPos; 
out vec3 Normal; 
out vec4 PositionLightSpace; 
out mat3 TBN; 
uniform mat3 MV3x3; 
 
uniform vec3 camPos; 
uniform mat3 invmodel; 
 
out vec3 TangentViewPos;  
out vec3 TangentFragPos; 
out vec3 EyeDirection_cameraspace; 
out vec3 tangentdbg; 
out vec4 ShadowCoord; 
void main() 
{ 
tangentdbg = vertexTangent_modelspace; 
    TexCoords = texCoords; 
	//fragment position in world space 
    WorldPos = (model * vec4(pos, 1.0)).xyz; 
	Normal = normalize((model * vec4(normal,0.0)).xyz);	 
  gl_Position =  projection *view * model* vec4(pos, 1.0);	 
   // gl_Position =   P*V*M* vec4(pos, 1.0);	 
	 // model to camera = ModelView 
	vec3 vertexTangent_cameraspace = normalize(mat3(model )* vertexTangent_modelspace); 
    vec3 vertexBitangent_cameraspace = normalize(vertexBitangent_modelspace);//normalize(mat3(model) * cross(Normal,vertexTangent_modelspace));//normalize(mat3(model) * vertexBitangent_modelspace); 
    vec3 vertexNormal_cameraspace = normalize( Normal); 
    // re-orthogonalize T with respect to N 
	vertexTangent_cameraspace = normalize(vertexTangent_cameraspace - dot(vertexTangent_cameraspace, vertexNormal_cameraspace) * vertexNormal_cameraspace); 
    vertexBitangent_cameraspace = cross(vertexTangent_cameraspace,vertexNormal_cameraspace); 
    // then retrieve perpendicular vector B with the cross product of T and N 
	 TBN = transpose(mat3( 
		vertexTangent_cameraspace, 
		vertexBitangent_cameraspace, 
		vertexNormal_cameraspace	 
	)); 
	ShadowCoord =  projection *view * model* vec4(pos, 1.0); 
	TangentViewPos = TBN * camPos; 
	TangentFragPos = TBN * WorldPos; 
	 
	 
} 
¬
PBR.frag|
#version 330 core 
uniform samplerCube shadowcubemap; 
out vec4 FragColor; 
in vec2 TexCoords; 
in vec3 WorldPos; 
in vec3 Normal; 
in mat3 TBN; 
in vec4 PositionLightSpace; 
// material parameters 
uniform sampler2D albedoMap; 
uniform float ao; 
uniform float far_plane; 
uniform int isMap; 
uniform int HasNormal; 
uniform sampler2D metallicMap; 
uniform sampler2D roughnessMap; 
uniform sampler2D NormalMap; 
//lights 
#define MAX_LIGHTS 10 
uniform int numLights; 
uniform struct Light { 
    vec3 position; 
    vec3 color; 
} 
allLights[MAX_LIGHTS]; 
// lights 
 
uniform vec3 camPos; 
uniform float exposure; 
 
const float PI = 3.14159265359; 
 
float DistributionGGX(vec3 N, vec3 H, float roughness) 
{ 
    float a = roughness*roughness; 
    float a2 = a*a; 
    float NdotH = max(dot(N, H), 0.0); 
    float NdotH2 = NdotH*NdotH; 
 
    float nom   = a2; 
    float denom = (NdotH2 * (a2 - 1.0) + 1.0); 
    denom = PI * denom * denom; 
 
    return nom / denom; 
} 
 
float GeometrySchlickGGX(float NdotV, float roughness) 
{ 
    float r = (roughness + 1.0); 
    float k = (r*r) / 8.0; 
 
    float nom   = NdotV; 
    float denom = NdotV * (1.0 - k) + k; 
 
    return nom / denom; 
} 
 
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) 
{ 
    float NdotV = max(dot(N, V), 0.0); 
    float NdotL = max(dot(N, L), 0.0); 
    float ggx2 = GeometrySchlickGGX(NdotV, roughness); 
    float ggx1 = GeometrySchlickGGX(NdotL, roughness); 
 
    return ggx1 * ggx2; 
} 
 
vec3 fresnelSchlick(float cosTheta, vec3 F0) 
{ 
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0); 
} 
float ShadowCalculation(vec3 fragPos); 
 
void main() 
{		 
		 
	vec3 albedo; 
	if(isMap == 0){ 
		albedo = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2)); 
	}else{ 
		albedo = vec3(0,1,1); 
	} 
	float metallic  = texture(metallicMap, TexCoords).r; 
    float roughness = texture(roughnessMap, TexCoords).r; 
	//v is inverted? 
	vec3 TextureNormal_tangentspace = normalize((texture( NormalMap, TexCoords).rgb)*2-1); 
    vec3 N = normalize(Normal); 
	if(HasNormal == 1){ 
		N = TextureNormal_tangentspace; 
		//albedo = vec3(1,1,1); 
	}else{ 
		 
	} 
	 
    vec3 V = normalize(camPos - WorldPos); 
	if(HasNormal == 1){ 
	V = normalize(V*TBN); 
	} 
    vec3 R = reflect(-V, N);  
 
 
    vec3 F0 = vec3(0.04);  
    F0 = mix(F0, albedo, metallic); 
 
    // reflectance equation 
    vec3 Lo = vec3(0.0); 
    for(int i = 0; i < 4; ++i)  
    { 
        // calculate per-light radiance 
        vec3 L = normalize(allLights[i].position - WorldPos); 
		if(HasNormal == 1){ 
		L = normalize(L * TBN);//hmmm 
		} 
        vec3 H = normalize(V + L); 
		if(HasNormal == 1){ 
		H = normalize(H * TBN); 
		} 
        float distance = length(allLights[i].position - WorldPos); 
        float attenuation = 1.0 / (distance * distance); 
        vec3 radiance = allLights[i].color * attenuation; 
 
        // Cook-Torrance BRDF 
        float NDF = DistributionGGX(N, H, roughness);    
        float G   = GeometrySmith(N, V, L, roughness);       
        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); 
            
        vec3 nominator    = NDF * G * F;  
        float denominator = 4 * max(dot(V, N), 0.0) * max(dot(L, N), 0.0) + 0.001; // 0.001 to prevent divide by zero. 
        vec3 brdf = nominator / denominator; 
         
        // kS is equal to Fresnel value 
        vec3 kS = F; 
 
        vec3 kD = vec3(1.0) - kS; 
 
        kD *= 1.0 - metallic;	   
 
        // scale light by NdotL 
        float NdotL = max(dot(N, L), 0.0);         
 
        
        Lo += (kD * albedo / PI + brdf) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again 
    }    
     
 
    // this ambient lighting with environment lighting). 
    vec3 ambient = vec3(0.03) * albedo * ao; 
 
    vec3 color = ambient + Lo; 
 
    // HDR tonemapping remap to LDR since 1988 
    color = color / (color + vec3(1.0)); 
//	color = color * 1-ShadowCalculation(WorldPos); 
    // gamma correct 
    color = pow(color, vec3(1.0/2.2));  
	//color = N; 
	//color = albedo; 
    FragColor = vec4(color, 1.0); 
	//FragColor = vec4(vec3(1- ShadowCalculation(WorldPos)),1.0); 
	 
} 
// array of offset direction for sampling 
vec3 gridSamplingDisk[20] = vec3[] 
( 
   vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1),  
   vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1), 
   vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0), 
   vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1), 
   vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1) 
); 
 
float ShadowCalculation(vec3 fragPos){ 
    // Get vector between fragment position and light position 
    vec3 fragToLight = fragPos - allLights[0].position; 
 
    float currentDepth = length(fragToLight); 
 
    float shadow = 0.0; 
    float bias = 0.15; 
    int samples = 20; 
    float viewDistance = length(camPos - fragPos); 
    float diskRadius = (1.0 + (viewDistance / far_plane)) / 25.0; 
    for(int i = 0; i < samples; ++i) 
    { 
        float closestDepth = texture(shadowcubemap, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
        closestDepth *= far_plane;   // Undo mapping [0;1] 
        if(currentDepth - bias > closestDepth) 
            shadow += 1.0; 
    } 
    shadow /= float(samples); 
 
    return shadow; 
} 
¬
PBR.vert|
#version 330 core 
layout (location = 0) in vec3 pos; 
layout (location = 1) in vec3 normal; 
layout (location = 2) in vec2 texCoords; 
layout (location = 3) in vec3 vertexTangent_modelspace; 
layout (location = 4) in vec3 vertexBitangent_modelspace;//invlaid  
out vec2 TexCoords; 
out vec3 WorldPos; 
out vec3 Normal; 
out vec4 PositionLightSpace; 
uniform mat4 projection; 
uniform mat4 view; 
uniform mat4 model; 
out mat3 TBN; 
uniform mat3 MV3x3; 
void main() 
{ 
    TexCoords = texCoords; 
    WorldPos = vec3(model * vec4(pos, 1.0f)); 
    Normal = normalize((model * vec4(normal,0.0)).xyz); 
 
    gl_Position =  projection * view * vec4(WorldPos, 1.0); 
	 
	 // model to camera = ModelView 
	vec3 vertexTangent_cameraspace = normalize(mat3(model )* vertexTangent_modelspace); 
    vec3 vertexBitangent_cameraspace = normalize(mat3(model) * vertexBitangent_modelspace); 
    vec3 vertexNormal_cameraspace = normalize( Normal); 
    // re-orthogonalize T with respect to N 
	vertexTangent_cameraspace = normalize(vertexTangent_cameraspace - dot(vertexTangent_cameraspace, vertexNormal_cameraspace) * vertexNormal_cameraspace); 
    vertexBitangent_cameraspace = cross(vertexTangent_cameraspace,vertexNormal_cameraspace); 
    // then retrieve perpendicular vector B with the cross product of T and N 
	 TBN = transpose(mat3( 
		vertexTangent_cameraspace, 
		vertexBitangent_cameraspace, 
		vertexNormal_cameraspace	 
	)); 
	 
	 
} 
¬
Particle.frag|
#version 330 core 
 
// Interpolated values from the vertex shaders 
in vec2 UV; 
in vec4 particlecolor; 
 
// Ouput data 
out vec4 color; 
 
uniform sampler2D Texture; 
 
void main(){ 
	// Output color = color of the texture at the specified UV 
	color = texture( Texture, UV ) * particlecolor; 
//	color = vec4(1,1,1,1); 
 
} 
¬
Particle.vert|
#version 330 core 
 
// Input vertex data, different for all executions of this shader. 
layout(location = 0) in vec3 squareVertices; 
layout(location = 1) in vec4 xyzs; // Position of the center of the particule and size of the square 
layout(location = 2) in vec4 color; // Position of the center of the particule and size of the square 
 
// Output data ; will be interpolated for each fragment. 
out vec2 UV; 
out vec4 particlecolor; 
 
// Values that stay constant for the whole mesh. 
uniform vec3 CameraRight_worldspace; 
uniform vec3 CameraUp_worldspace; 
uniform mat4 VP; // Model-View-Projection matrix, but without the Model (the position is in BillboardPos; the orientation depends on the camera) 
 
void main() 
{ 
	float particleSize = xyzs.w; // because we encoded it this way. 
	vec3 particleCenter_wordspace = xyzs.xyz; 
	 
	vec3 vertexPosition_worldspace =  
		particleCenter_wordspace 
		+ CameraRight_worldspace * squareVertices.x * particleSize 
		+ CameraUp_worldspace * squareVertices.y * particleSize; 
 
	// Output position of the vertex 
	gl_Position = VP * vec4(vertexPosition_worldspace, 1.0f); 
 
	// UV of the vertex. No special space for this one. 
	UV = squareVertices.xy + vec2(0.5, 0.5); 
	particlecolor = color; 
} 
¬
Pass_fs.frag|
//FXAA  
// adapted from http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf 
 
#version 330 core 
 
out vec4 FragColor; 
in vec2 TexCoords; 
 
// material parameters 
 
uniform sampler2D R_filterTexture; 
uniform vec3 R_inverseFilterTextureSize; 
uniform float R_fxaaSpanMax; 
uniform float R_fxaaReduceMin; 
uniform float R_fxaaReduceMul; 
uniform int EnableFXAA; 
 
void FXAA(){ 
	vec2 texCoordOffset = R_inverseFilterTextureSize.xy; 
	 
	vec3 luma = vec3(0.299, 0.587, 0.114);	 
	float lumaTL = dot(luma, texture2D(R_filterTexture, TexCoords.xy + (vec2(-1.0, -1.0) * texCoordOffset)).xyz); 
	float lumaTR = dot(luma, texture2D(R_filterTexture, TexCoords.xy + (vec2(1.0, -1.0) * texCoordOffset)).xyz); 
	float lumaBL = dot(luma, texture2D(R_filterTexture, TexCoords.xy + (vec2(-1.0, 1.0) * texCoordOffset)).xyz); 
	float lumaBR = dot(luma, texture2D(R_filterTexture, TexCoords.xy + (vec2(1.0, 1.0) * texCoordOffset)).xyz); 
	float lumaM  = dot(luma, texture2D(R_filterTexture, TexCoords.xy).xyz); 
 
	vec2 dir; 
	dir.x = -((lumaTL + lumaTR) - (lumaBL + lumaBR)); 
	dir.y = ((lumaTL + lumaBL) - (lumaTR + lumaBR)); 
	 
	float dirReduce = max((lumaTL + lumaTR + lumaBL + lumaBR) * (R_fxaaReduceMul * 0.25), R_fxaaReduceMin); 
	float inverseDirAdjustment = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce); 
	 
	dir = min(vec2(R_fxaaSpanMax, R_fxaaSpanMax),  
		max(vec2(-R_fxaaSpanMax, -R_fxaaSpanMax), dir * inverseDirAdjustment)); 
 
	dir.x = dir.x * step(1.0, abs(dir.x)); 
 	dir.y = dir.y * step(1.0, abs(dir.y)); 
 	 
 
 	dir = dir * texCoordOffset; 
	vec3 result1 = (1.0/2.0) * ( 
		texture2D(R_filterTexture, TexCoords.xy + (dir * vec2(1.0/3.0 - 0.5))).xyz + 
		texture2D(R_filterTexture, TexCoords.xy + (dir * vec2(2.0/3.0 - 0.5))).xyz); 
 
	vec3 result2 = result1 * (1.0/2.0) + (1.0/4.0) * ( 
		texture2D(R_filterTexture, TexCoords.xy + (dir * vec2(0.0/3.0 - 0.5))).xyz + 
		texture2D(R_filterTexture, TexCoords.xy + (dir * vec2(3.0/3.0 - 0.5))).xyz); 
 
	float lumaMin = min(lumaM, min(min(lumaTL, lumaTR), min(lumaBL, lumaBR))); 
	float lumaMax = max(lumaM, max(max(lumaTL, lumaTR), max(lumaBL, lumaBR))); 
	float lumaResult2 = dot(luma, result2); 
	 
	//result2.x = 0; 
	if(lumaResult2 < lumaMin || lumaResult2 > lumaMax) 
		FragColor = vec4(result1, 1.0); 
	else 
		FragColor = vec4(result2, 1.0); 
 
} 
void main() 
{			 
	vec3 colour = texture(R_filterTexture,TexCoords).xyz; 
	//colour.x = 0; 
    FragColor = vec4(colour, 1.0); 
	 
	if(EnableFXAA == 1){	 
		FXAA();	 
	} 
	 
	  
} 
¬
Pass_vs.vert|
#version 330 core 
layout (location = 0) in vec3 pos; 
layout (location = 2) in vec2 texCoords; 
 
out vec2 TexCoords; 
void main() 
{ 
 
    TexCoords = (pos.xy+vec2(1,1))/2.0; 
	//Normal = normal; 
    gl_Position = vec4(pos, 1.0); 
	 
} 
¬
Querry.frag|
#version 420 core 
 
out vec4 FragColor; 
in vec2 TexCoords; 
in vec3 WorldPos; 
 
void main() 
{			 
	 
    FragColor = vec4(1); 
} 
 
 
 
¬
Querry.vert|
#version 420 core 
layout (location = 0) in vec3 pos; 
layout (location = 1) in vec3 normal; 
layout (location = 2) in vec2 texCoords; 
layout (location = 3) in vec3 vertexTangent_modelspace; 
layout (location = 4) in vec3 vertexBitangent_modelspace;  
 
out vec3 WorldPos; 
 
uniform mat4 MVP; 
 
void main() 
{ 
    gl_Position =  MVP* vec4(pos, 1.0);	 
	 
} 
¬
SSAO.Frag|
#version 330 core 
out float FragColor; 
in vec2 TexCoords; 
 
uniform sampler2D gPosition; 
uniform sampler2D gNormal; 
uniform sampler2D texNoise; 
 
uniform vec3 samples[64]; 
uniform mat4 projection; 
float radius = 0.5; 
float bias = 0.025; 
float kernelSize = 64; 
uniform int height; 
uniform int width; 
// tile noise texture over screen based on screen dimensions divided by noise size 
vec2 noiseScale = vec2(width/4.0, height/4.0);  
 
void main() 
{ 
	vec3 fragPos   = texture(gPosition, TexCoords).rgb; 
	vec3 normal    = normalize(texture(gNormal, TexCoords).rgb); 
	vec3 randomVec = texture(texNoise, TexCoords * noiseScale).rgb*2.0-1.0;  
	vec3 tangent   = normalize(randomVec - normal * dot(randomVec, normal)); 
	vec3 bitangent = cross(normal, tangent); 
	mat3 TBN       = mat3(tangent, bitangent, normal);  	 
	float occlusion = 0.0; 
	for(int i = 0; i < kernelSize; i++) 
	{ 
		// get sample position: 
		vec3 sample = TBN * samples[i];		 
		sample = fragPos + sample * radius;  
 
		// project sample position: 
		vec4 offset = vec4(sample, 1.0); 
		offset = projection * offset; 
		offset.xyz /= offset.w; 
		offset.xyz = offset.xyz * 0.5 + 0.5; 
 
		// get sample depth: 
		float sampleDepth = texture(gPosition, offset.xy).z;  
 
		// range check & accumulate: 
		//range check improves quality of AO 
		float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth)); 
		occlusion   += (sampleDepth >= sample.z + bias ? 1.0 : 0.0) * rangeCheck;      
	} 
	//sum occlusin over x samples 
	occlusion = 1.0 - (occlusion / kernelSize); 
	FragColor = occlusion;    
} 
¬
SSAO.vert|
#version 330 core 
layout (location = 0) in vec3 pos; 
layout (location = 1) in vec3 normal; 
layout (location = 2) in vec2 texCoords; 
 
out vec2 TexCoords; 
 
void main(){ 
    //TexCoords = texCoords; 
	TexCoords = (pos.xy+vec2(1,1))/2.0; 
    gl_Position =  vec4(pos, 1.0);	 
} 
¬
Shadow.glh|
int MaxShadowDistance = 100; 
uniform samplerCube shadowcubemap; 
uniform samplerCube shadowcubemap2; 
uniform sampler2D shadowdirmap; 
uniform sampler2D shadowdirma2; 
uniform sampler2D shadowdirmap3; 
uniform sampler2D shadowdirmap4; 
 
vec3 gridSamplingDisk[20] = vec3[] 
( 
   vec3(1, 1, 1), vec3(1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1),  
   vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1), 
   vec3(1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0), 
   vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1), 
   vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, -1, -1), vec3(0, 1, -1) 
); 
 
 
float ShadowCalculationCube(const vec3 fragPos,Light lpos){ 
    // Get vector between fragment position and light position 
    vec3 fragToLight = fragPos - lpos.position; 
	 
    float currentDepth = length(fragToLight); 
	if(currentDepth > MaxShadowDistance){ 
	//	return 0.0f; 
	} 
    float shadow = 0.0f; 
    float bias = 0.09f; 
    int samples = 20; 
    float viewDistance = length(viewPos - fragPos); 
    float diskRadius = (1.0f + (viewDistance / far_plane)) / 25.0f; 
    for(int i = 0; i < samples; ++i) 
    { 
		float closestDepth = 0; 
		if(lpos.ShadowID == 0){ 
		 closestDepth = texture(shadowcubemap, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
		}else if(lpos.ShadowID == 1){ 
		 closestDepth = texture(shadowcubemap2, fragToLight + gridSamplingDisk[i] * diskRadius).r; 
		} 
		 
        closestDepth *= far_plane;    
        if(currentDepth - bias > closestDepth) 
            shadow += 1.0f; 
    } 
    shadow /= float(samples);//average of samples 
	//cleanup the low shadow areas 
	if(shadow < 0.25f){ 
		return 0.0f; 
	} 
    return shadow; 
} 
 
float ShadowCalculationDir(const vec3 fragPos, Light lpos){ 
     vec3 fragToLight = lpos.Direction;//fragPos - lpos.position; 
//	vec3 fragToLight = fragPos - allLights[0].position; 
     float currentDepth = fragPos.z;//length(fragToLight); 
	 vec2 coords = fragPos.xy; 
 
	 
	//float closestDepth = texture(shadowdirmap,fragToLight.xy).r; 
	if(texture( shadowdirmap, fragPos.xy ).z  <  fragPos.z){ 
		return 1.0f; 
	} 
    return 0.0f; 
 
} 
¬
UI_fs.frag|
#version 330 core 
in vec2 TexCoords; 
out vec4 color; 
 
uniform sampler2D text; 
uniform vec3 textColor; 
uniform int UseColour; 
void main() 
{     
  //  vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); 
	vec4 outc = UseColour + texture(text, TexCoords); 
    color = vec4(textColor * outc.rgb,outc.a) ; 
	//color = vec4(TexCoords,0,0); 
}   
¬
UI_vs.vert|
#version 330 core 
layout (location = 0) in vec4 vertex; // vec2 pos & vec2 texure coods 
out vec2 TexCoords; 
 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
    TexCoords = vertex.zw; 
}   
¬
depthbasic_fs.frag|
#version 430 
 
in vec4 FragPos; 
out vec4 Colour; 
 
uniform vec3 lightPos; 
uniform float far_plane; 
uniform int Ispoint; 
void main() 
{ 
	if(Ispoint == 1){ 
    // get distance between fragment and light source 
    float lightDistance = length(FragPos.xyz - lightPos); 
     
    // map to [0;1] range by dividing by far_plane 
    lightDistance = lightDistance / far_plane; 
     
    // Write this as modified depth 
    gl_FragDepth = lightDistance; 
	}else{ 
	gl_FragDepth = gl_FragCoord.z; 
	} 
	Colour = vec4(1); 
	 
}   
¬
depthbasic_geo.geo|
#version 330 core 
layout (triangles) in; 
layout (triangle_strip, max_vertices=18) out; 
 
uniform mat4 shadowMatrices[6]; 
 
out vec4 FragPos; // FragPos from GS (output per emitvertex) 
 
void main() 
{ 
    for(int face = 0; face < 6; ++face) 
    { 
        gl_Layer = face; // built-in variable that specifies to which face we render. 
        for(int i = 0; i < 3; ++i) // for each triangle's vertices 
        { 
            FragPos = gl_in[i].gl_Position; 
            gl_Position = shadowMatrices[face] * FragPos; 
            EmitVertex(); 
        }     
        EndPrimitive(); 
    } 
}   
¬
depthbasic_vs.vert|
#version 430 
 
layout (location = 0) uniform mat4 modelview;	//modelview matrix 
layout (location = 1) uniform mat4 MVP;	//projection matrix 
layout (location = 2) uniform vec4 lightpos;	//light position 
layout (location = 3) uniform mat4 lightmatrix;	//light matrix 
layout (location = 4) uniform mat4 lightproj;	//light projection matrix 
 
layout (location = 0) in vec4 vertposition;	//vertex attribute: position 
 
out vec4 outNormal;		//output: normal 
out vec4 lightvec;		//output: light vector 
out vec4 viewvec;		//output: view vector 
out vec2 outUV;			//output: texcoords 
out vec4 outPosInLight;	//output: vertex position in light space 
out vec4 position; 
uniform mat4 model; 
uniform int Ispoint; 
void main() 
{	 
	if(Ispoint == 1){ 
		gl_Position = model*vertposition; 
	}else{ 
		gl_Position = MVP*model*vertposition; 
	} 
	position = vertposition; 
 
} 
¬
line_fs.frag|
#version 330 core 
 
out vec4 color; 
in vec3 colr; 
 
uniform vec3 textColor; 
 
void main() 
{     
   // color = vec4(textColor, 1.0); 
   color = vec4(colr, 1.0); 
}   
¬
line_vs.vert|
#version 330 core 
layout (location = 0) in vec2 vertex; // vec2 pos & vec2 texure coods 
layout (location = 1) in vec3 col; 
 
out vec3 colr; 
 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
	colr = col; 
}   
¬
skybox.frag|
#version 330 core 
in vec3 TexCoords; 
out vec4 color; 
 
uniform samplerCube skybox; 
 
void main() 
{     
    color = texture(skybox, TexCoords)*1.5f; 
} 
¬
skybox.vert|
#version 330 core 
layout (location = 0) in vec3 position; 
out vec3 TexCoords; 
 
uniform mat4 projection; 
uniform mat4 view; 
 
 
void main() 
{ 
    vec4 pos =  projection  *view * vec4(position, 1.0);   
	gl_Position = pos.xyww; 
    TexCoords = normalize(position.xyz); 
}   
¬
text_fs.frag|
#version 330 core 
in vec2 TexCoords; 
out vec4 color; 
 
uniform sampler2D text; 
uniform vec3 textColor; 
 
void main() 
{     
    vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); 
    color = vec4(textColor, 1.0) * sampled; 
}   
¬
text_fs_Atlas.frag|
#version 330 core 
in vec2 TexCoords; 
out vec4 color; 
 
uniform sampler2D text; 
uniform vec3 textColor; 
 
void main() 
{     
    vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); 
    color = vec4(textColor, 1.0) * sampled; 
}   
¬
text_vs.vert|
#version 330 core 
layout (location = 0) in vec4 vertex; // vec2 pos & vec2 texure coods 
out vec2 TexCoords; 
 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
    TexCoords = vertex.zw; 
}   
¬
text_vs_Atlas.vert|
#version 330 core 
layout (location = 0) in vec4 vertex; // vec2 pos & vec2 texure coods 
out vec2 TexCoords; 
 
uniform mat4 projection; 
 
void main() 
{ 
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); 
    TexCoords = vertex.zw; 
}   
¬
